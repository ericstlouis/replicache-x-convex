"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[601],{7941:function(t,e,i){let a,n,s,r,l;i.d(e,{Gb:function(){return lK}});var o,h,u,c,d,w,f,p,_,v,m,y,g,b,k,M,I,D,S,W,H,x,C,E,N,P,R,O,A,V,j,U,L,q,F,T,z,G,J,B,K,Y,$,X,Q,Z,tt,te,ti,ta,tn,ts,tr,tl,to,th,tu,tc,td,tw,tf,tp,t_,tv,tm,ty,tg,tb,tk,tM,tI,tD,tS,tW,tH,tx,tC,tE,tN,tP,tR,tO,tA,tV,tj,tU,tL,tq,tF,tT,tz,tG,tJ,tB,tK,tY,t$,tX,tQ,tZ,t0,t1,t2,t4,t5,t3,t7,t6,t8,t9,et,ee,ei,ea,en,es,er,el,eo,eh,eu,ec,ed,ew,ef,ep,e_,ev,em,ey,eg,eb,ek,eM,eI,eD,eS,eW,eH,ex,eC,eE,eN,eP,eR,eO,eA,eV,ej,eU,eL,eq,eF,eT,ez,eG,eJ,eB,eK,eY,e$,eX,eQ,eZ,e0,e1,e2,e4,e5,e3,e7,e6,e8,e9,it,ie,ii,ia,is,ir,il,io,ih,iu,ic,id,iw,ip,i_,iv,im,iy,ig,ib,ik,iM,iI,iD,iS,iW,iH,ix,iC,iE,iN,iP,iR,iO,iA,iV,ij,iU,iL,iq,iF,iT,iz,iG,iJ=i(9902),iB=i(9954),iK=i(4498),iY=i(4307),i$=i(9826),iX=i(4413),iQ=i(9058),iZ=i(9252),i0=i(6457),i1=i(6328),i2=i(4230),i4=Object.defineProperty,i5=Object.getOwnPropertyDescriptor,i3=Object.getOwnPropertyNames,i7=Object.prototype.hasOwnProperty,i6=(t,e,i,a)=>{if(e&&"object"==typeof e||"function"==typeof e)for(let n of i3(e))i7.call(t,n)||n===i||i4(t,n,{get:()=>e[n],enumerable:!(a=i5(e,n))||a.enumerable});return t};parseInt("1.0".split(".")[1],10);var i8="/api/1.0",i9=i8+"/license/status",at=i8+"/license/active";function ae(t){ai(t,"boolean")}function ai(t,e){typeof t!==e&&an(t,e)}function aa(t){null===t&&an(t,"object"),ai(t,"object")}function an(t,e){let i;throw Error((i="Invalid type: ",null==t?i+=t:i+="".concat(typeof t," `").concat(t,"`"),i+", expected ".concat(e)))}async function as(t,e,i,a,n){var s,r;n=n.withContext("licenseActive");let l=new URL(at,e),o=JSON.stringify({licenseKey:i,profileID:a});null===(s=n.debug)||void 0===s||s.call(n,"Sending ".concat(l),o);let h=await (await t("post",l.toString(),o,{"Content-Type":"application/json",Accept:"application/json"})).text();null===(r=n.debug)||void 0===r||r.call(n,"Got ".concat(l),h),aa(JSON.parse(h))}async function ar(t,e,i,a){var n,s;a=a.withContext("getLicenseStatus");let r=new URL(i9,e),l=JSON.stringify({licenseKey:i});null===(n=a.debug)||void 0===n||n.call(a,"Sending ".concat(r),l);let o=await (await t("post",r.toString(),l,{"Content-Type":"application/json",Accept:"application/json"})).text();null===(s=a.debug)||void 0===s||s.call(a,"Got ".concat(r),o);let h=JSON.parse(o);return aa(h),ai(h.status,"string"),ae(h.disable),ae(h.pleaseUpdate),h}new URL("https://replicache-license.herokuapp.com/");var al="This key only good for automated testing",ao=(new URL("http://localhost:8080/"),new URL("https://replicache-license.herokuapp.com/"));function ah(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"Assertion failed";if(!t)throw Error(e)}function au(t){ad(t,"string")}function ac(t){ad(t,"number")}function ad(t,e){typeof t!==e&&ap(t,e)}function aw(t){null===t&&ap(t,"object"),ad(t,"object")}function af(t){Array.isArray(t)||ap(t,"array")}function ap(t,e){let i;throw Error((i="Invalid type: ",null==t?i+=t:i+="".concat(typeof t," `").concat(t,"`"),i+", expected ".concat(e)))}function a_(t){if(void 0===t)throw Error("Expected non undefined value")}function av(){throw Error("Unreachable")}new URL("https://replicache-license-staging.herokuapp.com/");var am=Object.prototype.hasOwnProperty,ay=Object.hasOwn||((t,e)=>am.call(t,e));function ag(t,e){if(t===e)return!0;if(typeof t!=typeof e)return!1;switch(typeof t){case"boolean":case"number":case"string":return!1}if(Array.isArray(t)){if(!Array.isArray(e)||t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!ag(t[i],e[i]))return!1;return!0}if(null===t||null===e||Array.isArray(e))return!1;let i=0;for(let a in t)if(ay(t,a)){if(!ag(t[a],e[a]))return!1;i++}let a=0;for(let t in e)ay(e,t)&&a++;return i===a}function ab(t){}async function ak(t,e,i,a){let n={headers:{"Content-type":"application/json",Authorization:e,"X-Replicache-RequestID":i},body:JSON.stringify(a),method:"POST"},s=new Request(t,n),r=await fetch(s),l=r.status;return 200!==l?[void 0,{httpStatusCode:l,errorMessage:await r.text()}]:[r,{httpStatusCode:l,errorMessage:""}]}function aM(t,e){var i,a;if(t===e)return 0;if(null===t)return -1;if(null===e)return 1;let n=aI(t),s=aI(e);return"string"==typeof n||"string"==typeof s?(i=String(n))===(a=String(s))?0:i<a?-1:1:n-s}function aI(t){return"string"==typeof t||"number"==typeof t?t:t.order}function aD(t,e){return"object"==typeof t&&null!==t&&t.error===e}function aS(t){return"string"==typeof t.error}function aW(t){return aD(t,"ClientStateNotFound")}function aH(t){if(!aD(t,"VersionNotSupported"))return!1;let{versionType:e}=t;switch(e){case void 0:case"pull":case"push":case"schema":return!0}return!1}function ax(t){aw(t),ac(t.httpStatusCode),au(t.errorMessage)}function aC(t){for(let e of(af(t),t))!function(t){switch(aw(t),t.op){case"put":au(t.key),t.value;break;case"del":au(t.key);break;case"clear":break;default:throw Error("unknown patch op `".concat(t.op,"`, expected one of `put`, `del`, `clear`"))}}(e)}var aE=new WeakSet;new WeakSet;function aN(t){if(void 0!==t)return t}var aP=Promise.resolve(!0),aR=Promise.resolve(!1),aO=(Promise.resolve(void 0),Promise.resolve()),aA=Symbol(),aV=(h=new WeakMap,class{has(t){switch(this.o.get(t)){case void 0:return(0,iJ._)(this,h).has(t);case aA:return aR;default:return aP}}async get(t){let e=this.o.get(t);switch(e){case aA:return;case void 0:return aN(await (0,iJ._)(this,h).get(t));default:return e}}put(t,e){return this.o.set(t,e),aO}del(t){return this.o.set(t,aA),aO}release(){(0,iJ._)(this,h).release()}get closed(){return(0,iJ._)(this,h).closed}constructor(t){(0,iQ._)(this,"o",new Map),(0,iB._)(this,h,{writable:!0,value:void 0}),(0,iK._)(this,h,t)}}),aj={durability:"relaxed"},aU="chunks",aL=(u=new WeakMap,c=new WeakMap,d=new WeakMap,w=new WeakSet,class{read(){return(0,i$._)(this,w,lZ).call(this,az)}write(){return(0,i$._)(this,w,lZ).call(this,aT)}async close(){(0,iJ._)(this,d)||(await (0,iJ._)(this,u)).close(),(0,iK._)(this,c,!0)}get closed(){return(0,iJ._)(this,c)}constructor(t){(0,iX._)(this,w),(0,iB._)(this,u,{writable:!0,value:void 0}),(0,iB._)(this,c,{writable:!0,value:!1}),(0,iB._)(this,d,{writable:!0,value:!1}),(0,iK._)(this,u,new Promise((e,i)=>{let a=indexedDB.open(t);a.onupgradeneeded=()=>{a.result.createObjectStore(aU)},a.onsuccess=()=>{let t=a.result;t.onversionchange=()=>t.close(),e(t)},a.onerror=()=>i(a.error)}))}}),aq=(f=new WeakMap,p=new WeakMap,class{has(t){return new Promise((e,i)=>{let a=aG((0,iJ._)(this,f)).count(t);a.onsuccess=()=>e(a.result>0),a.onerror=()=>i(a.error)})}get(t){return new Promise((e,i)=>{let a=aG((0,iJ._)(this,f)).get(t);a.onsuccess=()=>e(aN(a.result)),a.onerror=()=>i(a.error)})}release(){(0,iK._)(this,p,!0)}get closed(){return(0,iJ._)(this,p)}constructor(t){(0,iB._)(this,f,{writable:!0,value:void 0}),(0,iB._)(this,p,{writable:!0,value:!1}),(0,iK._)(this,f,t)}}),aF=(_=new WeakMap,v=new WeakMap,class extends aV{commit(){return 0===this.o.size?aO:new Promise((t,e)=>{let i=(0,iJ._)(this,_),a=aG(i);for(let[t,e]of this.o)e===aA?a.delete(t):a.put(e,t);i.oncomplete=()=>t(),i.onerror=()=>e(i.error)})}release(){(0,iK._)(this,v,!0)}get closed(){return(0,iJ._)(this,v)}constructor(t){super(new aq(t)),(0,iB._)(this,_,{writable:!0,value:void 0}),(0,iB._)(this,v,{writable:!0,value:!1}),(0,iK._)(this,_,t)}});function aT(t){return new aF(t.transaction(aU,"readwrite",aj))}function az(t){return new aq(t.transaction(aU,"readonly"))}function aG(t){return t.objectStore(aU)}var aJ=class extends Error{constructor(...t){super(...t),(0,iQ._)(this,"name","IDBNotFoundError")}},aB=(m=new WeakMap,y=new WeakMap,g=new WeakMap,class{release(){(0,iJ._)(this,y).call(this),(0,iK._)(this,g,!0)}get closed(){return(0,iJ._)(this,g)}has(t){return Promise.resolve((0,iJ._)(this,m).has(t))}get(t){return Promise.resolve((0,iJ._)(this,m).get(t))}constructor(t,e){(0,iB._)(this,m,{writable:!0,value:void 0}),(0,iB._)(this,y,{writable:!0,value:void 0}),(0,iB._)(this,g,{writable:!0,value:!1}),(0,iK._)(this,m,t),(0,iK._)(this,y,e)}}),aK=(b=new WeakMap,class extends aV{commit(){return this.o.forEach((t,e)=>{t===aA?(0,iJ._)(this,b).delete(e):(0,iJ._)(this,b).set(e,t)}),this.o.clear(),this.release(),aO}constructor(t,e){super(new aB(t,e)),(0,iB._)(this,b,{writable:!0,value:void 0}),(0,iK._)(this,b,t)}}),aY=new Map,a$=(k=new WeakMap,M=new WeakMap,I=new WeakMap,class{async read(){let t=await (0,iJ._)(this,M).read();return new aB((0,iJ._)(this,k),t)}async write(){let t=await (0,iJ._)(this,M).write();return new aK((0,iJ._)(this,k),t)}close(){return(0,iK._)(this,I,!0),aO}get closed(){return(0,iJ._)(this,I)}constructor(t){(0,iB._)(this,k,{writable:!0,value:void 0}),(0,iB._)(this,M,{writable:!0,value:void 0}),(0,iB._)(this,I,{writable:!0,value:!1});let e=aY.get(t),i,a;e?{lock:i,map:a}=e:(i=new i1.z,a=new Map,aY.set(t,{lock:i,map:a})),(0,iK._)(this,M,i),(0,iK._)(this,k,a)}}),aX=class extends Error{constructor(...t){super(...t),(0,iQ._)(this,"name","AbortError")}},aQ=Promise.resolve();function aZ(t,e){return 0===t?aQ:new Promise((i,a)=>{let n=setTimeout(()=>{i()},t);e&&e.addEventListener("abort",()=>{clearTimeout(n),a(new aX("Aborted"))})})}async function a0(t,e,i,a,n){if(!n.aborted){var s,r,l,o,h;for(null===(s=(a=a.withContext("bgIntervalProcess",t)).debug)||void 0===s||s.call(a,"Starting");!n.aborted;){try{await aZ(i(),n)}catch(t){if(!(t instanceof aX))throw t}if(!n.aborted){null===(l=a.debug)||void 0===l||l.call(a,"Running");try{await e()}catch(t){n.aborted?null===(o=a.debug)||void 0===o||o.call(a,"Error running most likely due to close.",t):null===(h=a.error)||void 0===h||h.call(a,"Error running.",t)}}}null===(r=a.debug)||void 0===r||r.call(a,"Stopping")}}new Promise(()=>{});var a1={};function a2(t){switch(typeof t){case"string":case"number":case"boolean":return JSON.stringify(t);case"undefined":return"undefined";case"bigint":return t.toString()+"n";default:return null===t?"null":Array.isArray(t)?"array":typeof t}}function a4(t,e){if(!(null==e?void 0:e.length))return a2(t);let i=t;for(let t of e)i=i[t];return a2(i)}function a5(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t=>String(t);if(1===e.length)return i(e[0]);let a="".concat(i(e[e.length-2])," ").concat(t," ").concat(i(e[e.length-1]));return 2===e.length?a:"".concat(e.slice(0,-2).map(i).join(", "),", ").concat(a)}function a3(t,e,i){let a=a8(t,e,i);if(!a.ok)throw TypeError(a.error);return a.value}function a7(t,e,i){return a8(t,e,i).ok}function a6(t,e,i){a3(t,e,i)}function a8(t,e,i){let a=e.try(t,i?{mode:i}:void 0);return a.ok?a:{ok:!1,error:function(t,e){var i,a;let n=t.issues[0],{path:s}=n,r=(null==s?void 0:s.length)?" at ".concat(s.join(".")):"";switch(n.code){case"invalid_type":return"Expected ".concat(a5("or",n.expected)).concat(r,". Got ").concat(a4(e,s));case"missing_value":{let t=s&&s.length>1?" at ".concat(s.slice(0,-1).join(".")):"";return(null===(i=n.path)||void 0===i?void 0:i.length)?"Missing property ".concat(n.path.at(-1)).concat(t):"TODO Unknown missing property".concat(t)}case"invalid_literal":return"Expected literal value ".concat(a5("or",n.expected,a2)).concat(r," Got ").concat(a4(e,s));case"invalid_length":return"Expected array with length ".concat(n.minLength===n.maxLength?n.minLength:"between ".concat(n.minLength," and ").concat(n.maxLength)).concat(r,". Got array with length ").concat(e.length);case"unrecognized_keys":return 1===n.keys.length?"Unexpected property ".concat(n.keys[0]).concat(r):"Unexpected properties ".concat(a5("and",n.keys)).concat(r);case"invalid_union":return"Invalid union value".concat(r);case"custom_error":{let{error:t}=n;return"".concat(t?"string"==typeof t?t:null!==(a=t.message)&&void 0!==a?a:"unknown":"unknown").concat(r,". Got ").concat(a4(e,s))}}}(a,t)}}function a9(t){return t}function nt(t){return i2.object(t)}function ne(t){return i2.array(t)}function ni(t){return i2.record(t)}((t,e)=>{for(var i in e)i4(t,i,{get:e[i],enumerable:!0})})(a1,{assert:()=>a6,is:()=>a7,parse:()=>a3,readonly:()=>a9,readonlyArray:()=>ne,readonlyObject:()=>nt,readonlyRecord:()=>ni,test:()=>a8}),i6(a1,i2,"default"),o&&i6(o,i2,"default");var na="u">typeof crypto&&"u">typeof crypto.randomUUID?function(){return crypto.randomUUID()}:function(){var t;return t=Uint8Array.from({length:36},()=>256*Math.random()),nn.map((e,i)=>{switch(e){case 0:return(15&t[i]).toString(16);case 1:return((3&t[i])+8).toString(16);case 3:return"4";case 2:return"-"}}).join("")},nn=[0,0,0,0,0,0,0,0,2,0,0,0,0,2,3,0,0,0,2,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0],ns=/^[0-9a-v-]+$/,nr="00000000-0000-4000-8000-000000000000",nl=(l=0,()=>{var t;r||(r=""+na().replaceAll("-","").slice(0));let e=String(l++);return t=r,ah(e.length<=12),t+e.padStart(12,"0")});function no(t){a3(t,nh,void 0)}var nh=a1.string().assert(function(t){return"string"==typeof t&&ns.test(t)},"Invalid hash"),nu=class{constructor(t,e,i){(0,iQ._)(this,"hash",void 0),(0,iQ._)(this,"data",void 0),(0,iQ._)(this,"meta",void 0),ah(!i.includes(t),"Chunk cannot reference itself"),this.hash=t,this.data=e,this.meta=i}};function nc(t){if(!Array.isArray(t))throw Error("Meta must be an array");for(let e of t)au(e)}function nd(){throw Error("unexpected call to compute chunk hash")}function nw(t,e,i){return new nf(t,e,i).compute()}var nf=(D=new WeakMap,S=new WeakMap,W=new WeakMap,H=new WeakMap,x=new WeakMap,C=new WeakMap,E=new WeakMap,N=new WeakMap,P=new WeakSet,R=new WeakSet,O=new WeakSet,A=new WeakSet,class{async compute(){for(let t of(0,iJ._)(this,D))await (0,i$._)(this,P,l0).call(this,t,1);if(await Promise.all(Array.from((0,iJ._)(this,W).values(),t=>(0,i$._)(this,O,l2).call(this,t))),(0,iJ._)(this,N)){let t;ah((0,iJ._)(this,H).areRefsCounted),ah((0,iJ._)(this,x));do for(let e of(t=!1,(0,iJ._)(this,W).values()))if(!(0,iJ._)(this,H).areRefsCounted(e)&&!(0,iJ._)(this,x).has(e)&&0!==(0,iJ._)(this,C).get(e)){await (0,i$._)(this,R,l1).call(this,e,1),t=!0;break}while(t)}for(let t of(0,iJ._)(this,S))await (0,i$._)(this,P,l0).call(this,t,-1);return(0,iJ._)(this,C)}constructor(t,e,i){(0,iX._)(this,P),(0,iX._)(this,R),(0,iX._)(this,O),(0,iX._)(this,A),(0,iB._)(this,D,{writable:!0,value:void 0}),(0,iB._)(this,S,{writable:!0,value:void 0}),(0,iB._)(this,W,{writable:!0,value:void 0}),(0,iB._)(this,H,{writable:!0,value:void 0}),(0,iB._)(this,x,{writable:!0,value:void 0}),(0,iB._)(this,C,{writable:!0,value:void 0}),(0,iB._)(this,E,{writable:!0,value:void 0}),(0,iB._)(this,N,{writable:!0,value:void 0});let a=[],n=[];for(let e of t)e.old!==e.new&&(e.old&&n.push(e.old),e.new&&a.push(e.new));(0,iK._)(this,D,a),(0,iK._)(this,S,n),(0,iK._)(this,W,e),(0,iK._)(this,H,i),(0,iK._)(this,C,new Map),(0,iK._)(this,E,new Map),(0,iK._)(this,N,void 0!==i.areRefsCounted),(0,iK._)(this,x,(0,iJ._)(this,N)?new Set:null)}});function np(t){return"c/".concat(t,"/d")}function n_(t){return"c/".concat(t,"/m")}function nv(t){return"c/".concat(t,"/r")}function nm(t){return"h/".concat(t)}var ny=class extends Error{constructor(t){super("Chunk not found ".concat(t)),(0,iQ._)(this,"name","ChunkNotFoundError"),(0,iQ._)(this,"hash",void 0),this.hash=t}};async function ng(t,e){let i=await t.getChunk(e);if(i)return i;throw new ny(e)}async function nb(t,e){let i=await e.getHead(t);return ah(i,"Missing head ".concat(t)),i}var nk=(V=new WeakMap,j=new WeakMap,U=new WeakMap,class{async read(){return new nM(await (0,iJ._)(this,V).read(),(0,iJ._)(this,U))}async write(){return new nI(await (0,iJ._)(this,V).write(),(0,iJ._)(this,j),(0,iJ._)(this,U))}close(){return(0,iJ._)(this,V).close()}constructor(t,e,i){(0,iB._)(this,V,{writable:!0,value:void 0}),(0,iB._)(this,j,{writable:!0,value:void 0}),(0,iB._)(this,U,{writable:!0,value:void 0}),(0,iK._)(this,V,t),(0,iK._)(this,j,e),(0,iK._)(this,U,i)}}),nM=class{hasChunk(t){return this.e.has(np(t))}async getChunk(t){let e=await this.e.get(np(t));if(void 0===e)return;let i=await this.e.get(n_(t)),a;return void 0!==i?(nc(i),a=i):a=[],new nu(t,e,a)}mustGetChunk(t){return ng(this,t)}async getHead(t){let e=await this.e.get(nm(t));if(void 0!==e)return no(e),e}release(){this.e.release()}get closed(){return this.e.closed}constructor(t,e){(0,iQ._)(this,"e",void 0),(0,iQ._)(this,"assertValidHash",void 0),this.e=t,this.assertValidHash=e}},nI=(L=new WeakMap,q=new WeakMap,F=new WeakMap,T=new WeakSet,z=new WeakSet,G=new WeakSet,class extends nM{get kvWrite(){return this.e}async putChunk(t){let{hash:e,data:i,meta:a}=t;this.assertValidHash(e);let n=np(e),s=this.e.put(n,i),r;if(a.length>0){for(let t of a)this.assertValidHash(t);r=this.e.put(n_(e),a)}(0,iJ._)(this,q).add(e),await s,await r}setHead(t,e){return(0,i$._)(this,T,l5).call(this,t,e)}removeHead(t){return(0,i$._)(this,T,l5).call(this,t,void 0)}async commit(){let t=await nw((0,iJ._)(this,F).values(),(0,iJ._)(this,q),this);await (0,i$._)(this,z,l3).call(this,t),await this.e.commit()}async getRefCount(t){let e=await this.e.get(nv(t));if(void 0!==e){if(ac(e),e<0||e>65535||e!==(0|e))throw Error("Invalid ref count ".concat(e,". We expect the value to be a Uint16"));return e}}async getRefs(t){let e=await this.e.get(n_(t));return void 0===e?[]:(nc(e),e)}release(){this.e.release()}constructor(t,e,i){super(t,i),(0,iX._)(this,T),(0,iX._)(this,z),(0,iX._)(this,G),(0,iB._)(this,L,{writable:!0,value:void 0}),(0,iB._)(this,q,{writable:!0,value:new Set}),(0,iB._)(this,F,{writable:!0,value:new Map}),(0,iQ._)(this,"createChunk",(t,e)=>new nu((0,iJ._)(this,L)(),t,e)),(0,iK._)(this,L,e)}});function nD(t){if(t!==(0|t)||t<4||t>7)throw Error("Unsupported format version: ".concat(t));return t}var nS=(J=new WeakMap,B=new WeakMap,K=new WeakMap,Y=new WeakSet,class{read(){return(0,i$._)(this,Y,l6).call(this,t=>t.read())}write(){return(0,i$._)(this,Y,l6).call(this,t=>t.write())}close(){return(0,iJ._)(this,K).close()}get closed(){return(0,iJ._)(this,K).closed}constructor(t,e){(0,iX._)(this,Y),(0,iB._)(this,J,{writable:!0,value:void 0}),(0,iB._)(this,B,{writable:!0,value:void 0}),(0,iB._)(this,K,{writable:!0,value:void 0}),(0,iK._)(this,J,t),(0,iK._)(this,B,e),(0,iK._)(this,K,new aL(e))}});function nW(){return navigator.userAgent.includes("Firefox")}function nH(t,e){return nE(t.read(),e)}function nx(t,e){return nE(t.write(),e)}function nC(t,e){return nE(t.write(),async t=>{let i=await e(t);return await t.commit(),i})}async function nE(t,e){let i=await t;try{return await e(i)}finally{i.release()}}var nN=ni(nt({prefix:a1.string().optional(),jsonPointer:a1.string(),allowEmpty:a1.boolean().optional()}));function nP(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(let[i,a]of Object.entries(t)){let t=e[i];if(!t||!function(t,e){var i,a,n,s;return t.jsonPointer===e.jsonPointer&&(null!==(i=t.allowEmpty)&&void 0!==i&&i)===(null!==(a=e.allowEmpty)&&void 0!==a&&a)&&(null!==(n=t.prefix)&&void 0!==n?n:"")===(null!==(s=e.prefix)&&void 0!==s?s:"")}(a,t))return!1}return!0}var nR=nt({headHash:nh,mutatorNames:ne(a1.string()),indexes:nN,mutationIDs:ni(a1.number()),lastServerAckdMutationIDs:a1.record(a1.number()),disabled:a1.boolean()}),nO="client-groups";async function nA(t,e){let i=await e.getChunk(t);return function(t){aw(t);let e=new Map;for(let[i,a]of Object.entries(t))void 0!==a&&(a3(a,nR,void 0),e.set(i,a));return e}(null==i?void 0:i.data)}async function nV(t){let e=await t.getHead(nO);return e?nA(e,t):new Map}async function nj(t,e){let i=await nV(e);for(let[e,a]of t)nL(a,i.get(e));return nq(t,e)}async function nU(t,e,i){let a=await nV(i);nL(e,a.get(t));let n=new Map(a);return n.set(t,e),nq(n,i)}function nL(t,e){let i=new Set(t.mutatorNames);ah(i.size===t.mutatorNames.length,"A client group's mutatorNames must be a set."),void 0!==e&&(ah(nP(e.indexes,t.indexes),"A client group's index definitions must never change."),ah(nF(i,e.mutatorNames),"A client group's mutatorNames must never change."))}async function nq(t,e){let i=function(t,e){let i={};for(let[a,n]of t.entries())e.assertValidHash(n.headHash),i[a]={...n,mutatorNames:[...n.mutatorNames.values()]};return i}(t,e),a=Array.from(t.values(),t=>t.headHash),n=e.createChunk(i,a);return await e.putChunk(n),await e.setHead(nO,n.hash),t}function nF(t,e){if(e.length!==t.size)return!1;for(let i of e)if(!t.has(i))return!1;return!0}async function nT(t,e){return(await nV(e)).get(t)}function nz(t){for(let[e,i]of Object.entries(t.mutationIDs)){let a=t.lastServerAckdMutationIDs[e];if(void 0===a&&0!==i||a<i)return!0}return!1}async function nG(t,e){let i=await nT(t,e);if(!i)return;let a={...i,disabled:!0};await nU(t,a,e)}function nJ(t,e){let i=t.length,a=e.length,n=Math.min(i,a);for(let i=0;i<n;){let a=t.codePointAt(i),n=e.codePointAt(i);if(a!==n){if(a<128&&n<128)return a-n;let t=n$(a,nK),e=n$(n,nY);return function(t,e,i,a){let n=Math.min(e,a);for(let e=0;e<n;e++){let a=t[e],n=i[e];if(a!==n)return a-n}return e-a}(nK,t,nY,e)}i+=a>65535?2:1}return i-a}var nB=()=>Array.from({length:4},()=>0),nK=nB(),nY=nB();function n$(t,e){let i,a;if(t<128)return e[0]=t,1;if(t<=2047)i=1,a=192;else if(t<=65535)i=2,a=224;else if(t<=1114111)i=3,a=240;else throw Error("Invalid code point");e[0]=(t>>6*i)+a;let n=1;for(;i>0;i--){let a=t>>6*(i-1);e[n++]=128|63&a}return n}function nX(t,e){let i=0;for(;i<t;){let a=i+(t-i>>1),n=e(a);if(0===n)return a;n>0?i=a+1:t=a}return i}function*nQ(){for(var t=arguments.length,e=Array(t),i=0;i<t;i++)e[i]=arguments[i];for(let t of e)yield*t}function nZ(t,e,i){return[t,i>=7?e:e.map(t=>t.slice(0,2))]}async function n0(t,e,i,a){let n=await i.getNode(e);if(a!==i.rootHash)return n0(t,i.rootHash,i,i.rootHash);if(st(n))return n;let{entries:s}=n,r=n1(t,s);return r===s.length&&r--,n0(t,s[r][1],i,a)}function n1(t,e){return nX(e.length,i=>nJ(t,e[i][0]))}function n2(t,e,i){return t!==e.length&&e[t][0]===i}function n4(t,e,i){if(e>=7)return t;af(t),ah(t.length>=2);let[a,n]=t;ac(a),af(n);let s=a>0?au:ab;if(e>=7){for(let t of n)af(t),ah(t.length>=3),au(t[0]),s(t[1]),ac(t[2]);return t}return[a,n.map(t=>{let e;return af(t),ah(t.length>=2),au(t[0]),s(t[1]),e=i(t[0],t[1]),[t[0],t[1],e]})]}var n5=($=new WeakMap,class{maxKey(){return this.entries[this.entries.length-1][0]}getChildNodeSize(t){if(-1!==(0,iJ._)(this,$))return(0,iJ._)(this,$);let e=t.chunkHeaderSize;for(let t of this.entries)e+=t[2];return(0,iK._)(this,$,e)}c(t){(0,iK._)(this,$,-1),t.updateNode(this)}constructor(t,e,i){(0,iQ._)(this,"entries",void 0),(0,iQ._)(this,"hash",void 0),(0,iQ._)(this,"isMutable",void 0),(0,iB._)(this,$,{writable:!0,value:-1}),this.entries=t,this.hash=e,this.isMutable=i}});function n3(t,e){return nZ(t.level,t.entries,e)}var n7=(X=new WeakSet,class extends n5{set(t,e,i,a){let n,s=n1(t,this.entries);return n=n2(s,this.entries,t)?1:0,Promise.resolve((0,i$._)(this,X,l8).call(this,a,s,n,[t,e,i]))}del(t,e){let i=n1(t,this.entries);return n2(i,this.entries,t)?Promise.resolve((0,i$._)(this,X,l8).call(this,e,i,1)):Promise.resolve(this)}async *keys(t){for(let t of this.entries)yield t[0]}async *entriesIter(t){for(let t of this.entries)yield t}constructor(...t){super(...t),(0,iX._)(this,X),(0,iQ._)(this,"level",0)}});function n6(t,e,i){for(var a=arguments.length,n=Array(a>3?a-3:0),s=3;s<a;s++)n[s-3]=arguments[s];let r=t.slice(0,e);for(let t=0;t<n.length;t++)r.push(n[t]);for(let a=e+i;a<t.length;a++)r.push(t[a]);return r}var n8=(Q=new WeakSet,Z=new WeakSet,class t extends n5{async set(t,e,i,a){let n=n1(t,this.entries);n===this.entries.length&&n--;let s=this.entries[n][1],r=await (await a.getNode(s)).set(t,e,i,a),l=r.getChildNodeSize(a);if(l>a.maxSize||l<a.minSize)return(0,i$._)(this,Q,l9).call(this,a,n,r);let o=sn(r,a.getEntrySize);return(0,i$._)(this,Z,ot).call(this,a,n,o)}async del(t,e){let i=n1(t,this.entries);if(i===this.entries.length)return this;let a=this.entries[i][1],n=await e.getNode(a),s=n.hash,r=await n.del(t,e);if(r.hash===s)return this;if(0===r.entries.length){let t=n6(this.entries,i,1);return e.newInternalNodeImpl(t,this.level)}if(0===i&&1===this.entries.length)return r;if(r.getChildNodeSize(e)>e.minSize){let t=sn(r,e.getEntrySize);return(0,i$._)(this,Z,ot).call(this,e,i,t)}return(0,i$._)(this,Q,l9).call(this,e,i,r)}async *keys(t){for(let e of this.entries)yield*(await t.getNode(e[1])).keys(t)}async *entriesIter(t){for(let e of this.entries)yield*(await t.getNode(e[1])).entriesIter(t)}getChildren(t,e,i){let a=[];for(let n=t;n<e&&n<this.entries.length;n++)a.push(i.getNode(this.entries[n][1]));return Promise.all(a)}async getCompositeChildren(e,i,a){let{level:n}=this;if(0===i)return new t([],nl(),n-1,!0);let s=await this.getChildren(e,e+i,a);if(n>1){let e=[];for(let t of s)e.push(...t.entries);return new t(e,nl(),n-1,!0)}ah(1===n);let r=[];for(let t of s)r.push(...t.entries);return new n7(r,nl(),!0)}constructor(t,e,i,a){super(t,e,a),(0,iX._)(this,Q),(0,iX._)(this,Z),(0,iQ._)(this,"level",void 0),this.level=i}});function n9(t,e,i,a){return 0===i?new n7(t,e,a):new n8(t,e,i,a)}function st(t){return 0===t.level}function se(t,e,i,a){let n=[],s=[],r=0,l=[];for(let o of t){let t=e(o);t>=a?(l.length>0&&(n.push(l),s.push(r)),n.push([o]),s.push(t),r=0,l=[]):r+t>=i?(l.push(o),n.push(l),s.push(r+t),r=0,l=[]):(r+=t,l.push(o))}return r>0&&(s.length>0&&r+s[s.length-1]<=a?n[n.length-1].push(...l):n.push(l)),n}var si=nZ(0,[],7),sa=new n7([],nr,!1);function sn(t,e){let i=t.maxKey(),a=t.hash,n=e(i,a);return[i,a,n]}function ss(t){switch(typeof t){case"string":return 5+t.length;case"number":return t===(0|t)?t<=-1073741824||t>=1073741824-1?6:5:9;case"boolean":return 1;case"object":if(null===t)return 1;if(Array.isArray(t)){let e=6;for(let i of t)e+=ss(i);return e}{let e=6;for(let i in t)if(ay(t,i)){let a=t[i];void 0!==a&&(e+=ss(i)+ss(a))}return e}}throw Error("Invalid value. type: ".concat(typeof t,", value: ").concat(t))}function sr(t,e){return 11+ss(t)+ss(e)}var sl=(a=Symbol.asyncIterator,class{async getNode(t){if(t===nr)return sa;let e=this.p.get(t);if(e)return e;let i=n4((await this.a.mustGetChunk(t)).data,this.l,this.getEntrySize),a=n9(i[1],t,i[0],!1);return this.p.set(t,a),a}async get(t){let e=await n0(t,this.rootHash,this,this.rootHash),i=n1(t,e.entries);if(n2(i,e.entries,t))return e.entries[i][1]}async has(t){let e=await n0(t,this.rootHash,this,this.rootHash);return n2(n1(t,e.entries),e.entries,t)}async isEmpty(){let{rootHash:t}=this,e=await this.getNode(this.rootHash);return this.rootHash!==t?this.isEmpty():0===e.entries.length}scan(t){return sh(this.rootHash,()=>this.rootHash,this.rootHash,t,async t=>{let e=await this.getNode(t);return e?[e.level,e.isMutable?e.entries.slice():e.entries]:n4((await this.a.mustGetChunk(t)).data,this.l,this.getEntrySize)})}async *keys(){yield*(await this.getNode(this.rootHash)).keys(this)}async *entries(){yield*(await this.getNode(this.rootHash)).entriesIter(this)}[a](){return this.entries()}async *diff(t){let[e,i]=await Promise.all([this.getNode(this.rootHash),t.getNode(t.rootHash)]);yield*so(i,e,t,this)}constructor(t,e,i=nr,a=sr,n=11){(0,iQ._)(this,"p",new Map),(0,iQ._)(this,"a",void 0),(0,iQ._)(this,"l",void 0),(0,iQ._)(this,"rootHash",void 0),(0,iQ._)(this,"getEntrySize",void 0),(0,iQ._)(this,"chunkHeaderSize",void 0),this.a=t,this.l=e,this.rootHash=i,this.getEntrySize=a,this.chunkHeaderSize=n}});async function*so(t,e,i,a){if(t.level>e.level){let n=await t.getCompositeChildren(0,t.entries.length,i);yield*so(n,e,i,a);return}if(e.level>t.level){let n=await e.getCompositeChildren(0,e.entries.length,a);yield*so(t,n,i,a);return}if(st(t)&&st(e)){yield*function*(t,e){let i=t.length,a=e.length,n=0,s=0;for(;n<i&&s<a;){let i=t[n][0],a=e[s][0];i===a?(ag(t[n][1],e[s][1])||(yield{op:"change",key:i,oldValue:t[n][1],newValue:e[s][1]}),n++,s++):i<a?(yield{op:"del",key:i,oldValue:t[n][1]},n++):(yield{op:"add",key:a,newValue:e[s][1]},s++)}for(;n<i;n++)yield{op:"del",key:t[n][0],oldValue:t[n][1]};for(;s<a;s++)yield{op:"add",key:e[s][0],newValue:e[s][1]}}(t.entries,e.entries);return}for(let n of function*(t,e){let i=0,a=0,n;function s(t,e){-1===t[3]&&(t[3]=e)}function r(){return[i,0,0,-1]}for(;i<t.length&&a<e.length;)t[i][0]===e[a][0]?(ag(t[i][1],e[a][1])?n&&(s(n,0),yield n,n=void 0):(n||(n=r()),n[2]++,n[1]++,s(n,a)),i++,a++):t[i][0]<e[a][0]?(n||(n=r()),n[1]++,i++):(n||(n=r()),n[2]++,s(n,a),a++);a<e.length&&(n||(n=r()),n[2]+=e.length-a,s(n,a)),i<t.length&&(n||(n=r()),n[1]+=t.length-i),n&&(s(n,0),yield n)}(t.entries,e.entries)){let[s,r]=await Promise.all([t.getCompositeChildren(n[0],n[1],i),e.getCompositeChildren(n[3],n[2],a)]);yield*so(s,r,i,a)}}async function*sh(t,e,i,a,n){if(i===nr)return;let s=await n(i),r=s[1],l=0;if(a&&(l=n1(a,r)),s[0]>0)for(;l<r.length;l++)yield*sh(t,e,r[l][1],a,n),a="";else for(;l<r.length;l++){let i=e();if(t!==i){yield*sh(i,e,i,r[l][0],n);return}yield r[l]}}async function su(t,e){let i=[],a="add"===e?t=>({op:"add",key:t[0],newValue:t[1]}):t=>({op:"del",key:t[0],oldValue:t[1]});for await(let e of t.entries())i.push(a(e));return i}var sc="main";function sd(t){return sH(t.meta)}function sw(t){return 5===t.meta.type||3===t.meta.type}var sf=class{get meta(){return this.chunk.data.meta}get valueHash(){return this.chunk.data.valueHash}getMutationID(t,e){return sp(t,e,this.meta)}async getNextMutationID(t,e){return await this.getMutationID(t,e)+1}get indexes(){return this.chunk.data.indexes}constructor(t){(0,iQ._)(this,"chunk",void 0),this.chunk=t}};async function sp(t,e,i){switch(i.type){case 1:case 3:return i.lastMutationID;case 5:var a;return null!==(a=i.lastMutationIDs[t])&&void 0!==a?a:0;case 2:return i.mutationID;case 4:{if(i.clientID===t)return i.mutationID;let{basisHash:a}=i,n=await sS(a,e);return sp(t,e,n.meta)}default:av()}}async function s_(t,e){return(await sD(t,e)).filter(t=>sd(t)||function(t){return 2===t.type}(t.meta))}async function sv(t,e){return(await sD(t,e)).filter(t=>sd(t))}async function sm(t,e,i){let a=[],n=new Map(Object.entries(e));for(;!sw(t)&&n.size>0;){if(sd(t)){let{meta:e}=t,i=n.get(e.clientID);void 0!==i&&(e.mutationID<=i?n.delete(e.clientID):a.push(t))}let{basisHash:e}=t.meta;if(null===e)throw Error("Commit ".concat(t.chunk.hash," has no basis"));t=await sS(e,i)}return a}async function sy(t,e){let i=await e.getHead(t);return ah(i,"Missing head ".concat(t)),sb(i,e)}async function sg(t,e){return(await sb(t,e)).chunk.hash}async function sb(t,e){return sk(await sS(t,e),e)}async function sk(t,e){for(;!sw(t);){let{meta:i}=t;if(sH(i))t=await sS(i.baseSnapshotHash,e);else{let{basisHash:a}=i;if(null===a)throw Error("Commit ".concat(t.chunk.hash," has no basis"));t=await sS(a,e)}}return t}function sM(t,e){var i;let a=t.meta;return 5===a.type?[null!==(i=a.lastMutationIDs[e])&&void 0!==i?i:0,a.cookieJSON]:[a.lastMutationID,a.cookieJSON]}function sI(t,e){return aM(t.meta.cookieJSON,e.meta.cookieJSON)}async function sD(t,e){let i=await sS(t,e),a=[];for(;!sw(i);){let{meta:t}=i,{basisHash:n}=t;if(null===n)throw Error("Commit ".concat(i.chunk.hash," has no basis"));a.push(i),i=await sS(n,e)}return a.push(i),a}async function sS(t,e){var i;return function(t){let{data:e}=t,i=new Set;for(let t of e.indexes){let{name:e}=t.definition;if(i.has(e))throw Error("Duplicate index ".concat(e));i.add(e)}}(i=await e.mustGetChunk(t)),new sf(i)}async function sW(t,e){return sS(await nb(t,e),e)}function sH(t){return 4===t.type}function sx(t){return 2===t.type}function sC(t){null!==t.basisHash&&no(t.basisHash),t.cookieJSON,function(t){for(let e of(aw(t),Object.values(t)))ac(e)}(t.lastMutationIDs)}function sE(t){sC(t.meta)}function sN(t,e,i,a,n){return sO({type:5,basisHash:t,lastMutationIDs:e,cookieJSON:i},a,n)}function sP(t,e){return new sf(t(e,sR(e)))}function sR(t){let e=[t.valueHash],{meta:i}=t;switch(i.type){case 1:case 2:case 4:i.basisHash&&e.push(i.basisHash);break;case 3:case 5:break;default:av()}for(let i of t.indexes)e.push(i.valueHash);return e}function sO(t,e,i){return{meta:t,valueHash:e,indexes:i}}async function sA(t){let e=[];for await(let i of t)e.push(i);return e}function sV(t,e){return sA(e.diff(t))}var sj=(tt=new WeakMap,te=new WeakMap,ti=new WeakSet,class extends sl{updateNode(t){ah(t.isMutable),(0,iJ._)(this,te).delete(t.hash),t.hash=nl(),(0,i$._)(this,ti,oe).call(this,t)}newInternalNodeImpl(t,e){let i=new n8(t,nl(),e,!0);return(0,i$._)(this,ti,oe).call(this,i),i}newDataNodeImpl(t){let e=new n7(t,nl(),!0);return(0,i$._)(this,ti,oe).call(this,e),e}newNodeImpl(t,e){let i=n9(t,nl(),e,!0);return(0,i$._)(this,ti,oe).call(this,i),i}put(t,e){return(0,iJ._)(this,tt).withLock(async()=>{let i=await this.getNode(this.rootHash),a=this.getEntrySize(t,e),n=await i.set(t,e,a,this);if(n.getChildNodeSize(this)>this.maxSize){let t=this.chunkHeaderSize,e=se(n.entries,t=>t[2],this.minSize-t,this.maxSize-t),{level:i}=n,a=e.map(t=>sn(this.newNodeImpl(t,i),this.getEntrySize)),s=this.newInternalNodeImpl(a,i+1);this.rootHash=s.hash;return}this.rootHash=n.hash})}del(t){return(0,iJ._)(this,tt).withLock(async()=>{let e=await (await this.getNode(this.rootHash)).del(t,this),i=this.rootHash!==e.hash;return i&&(e.level>0&&1===e.entries.length?this.rootHash=e.entries[0][1]:this.rootHash=e.hash),i})}clear(){return(0,iJ._)(this,tt).withLock(()=>{(0,iJ._)(this,te).clear(),this.rootHash=nr})}flush(){return(0,iJ._)(this,tt).withLock(async()=>{let t=this.a;if(this.rootHash===nr){let e=t.createChunk(si,[]);return await t.putChunk(e),e.hash}let e=[],i=function t(e,i,a,n,s){let r=n.get(e);if(void 0===r)return e;if(st(r)){let t=a(n3(r,s),[]);return i.push(t),t.hash}let l=[],{entries:o}=r;for(let e=0;e<o.length;e++){let r=o[e],h=r[1],u=t(h,i,a,n,s);u!==h&&(o[e]=[r[0],u,r[2]]),l.push(u)}let h=a(n3(r,s),l);return i.push(h),h.hash}(this.rootHash,e,t.createChunk,(0,iJ._)(this,te),this.l);return await Promise.all(e.map(e=>t.putChunk(e))),(0,iJ._)(this,te).clear(),this.rootHash=i,i})}constructor(t,e,i=nr,a=8192,n=16384,s=sr,r){super(t,e,i,s,r),(0,iX._)(this,ti),(0,iB._)(this,tt,{writable:!0,value:new i1.H}),(0,iB._)(this,te,{writable:!0,value:new Map}),(0,iQ._)(this,"minSize",void 0),(0,iQ._)(this,"maxSize",void 0),this.minSize=a,this.maxSize=n}});function sU(t){let e;return()=>(void 0===e&&(e=t()),e)}var sL=class{constructor(t,e){(0,iQ._)(this,"meta",void 0),(0,iQ._)(this,"map",void 0),this.meta=t,this.map=e}},sq=class extends sL{flush(){return this.map.flush()}clear(){return this.map.clear()}};async function sF(t,e,i,a,n,s,r){try{for(let t of function(t,e,i,a){let n=function(t,e){if(""===e)return t;if(!e.startsWith("/"))throw Error("Invalid JSON pointer: ".concat(e));let i=e.split("/").slice(1).map(t=>t.replace(/~1/g,"/").replace(/~0/g,"~")),a=t;for(let t of i){let e;if(Array.isArray(a)){let i=function(t){if(!(t.startsWith("+")||t.startsWith("0")&&1!==t.length))return parseInt(t,10)}(t);if(void 0===i)return;e=a[i]}else{if(null===a)return;"object"==typeof a&&(e=a[t])}if(void 0===e)return;a=e}return a}(e,i);if(void 0===n){if(a)return[];throw Error("No value at path: ".concat(i))}let s=Array.isArray(n)?n:[n],r=[];for(let e of s)if("string"==typeof e)r.push(sT([e,t]));else throw Error("Unsupported target type");return r}(a,n,s,r))switch(i){case 0:await e.put(t,n);break;case 1:await e.del(t)}}catch(e){var l;null===(l=t.info)||void 0===l||l.call(t,"Not indexing value",n,":",e)}}function sT(t){let e=t[0],i=t[1];if(e.includes("\x00"))throw Error("Secondary key cannot contain null byte");return"\x00"+e+"\x00"+i}function sz(t,e){let i=sT([t,e||""]);return void 0===e?i.slice(0,i.length-1):i}function sG(t){if("\x00"!==t[0])throw Error("Invalid version");let e=t.indexOf("\x00",1);if(-1===e)throw Error("Invalid formatting");return[t.slice(1,e),t.slice(e+1)]}var sJ=(ta=new WeakMap,class{has(t){return this.map.has(t)}get(t){return this.map.get(t)}isEmpty(){return this.map.isEmpty()}getMapForIndex(t){let e=this.indexes.get(t);if(void 0===e)throw Error("Unknown index name: ".concat(t));return e.map}get closed(){return(0,iJ._)(this,ta).closed}close(){(0,iJ._)(this,ta).release()}constructor(t,e,i){(0,iB._)(this,ta,{writable:!0,value:void 0}),(0,iQ._)(this,"map",void 0),(0,iQ._)(this,"indexes",void 0),(0,iK._)(this,ta,t),this.map=e,this.indexes=i}});async function sB(t,e,i){var a;let n,s;return n=sK(a=await sW(t,e),e,i),s=new sl(e,i,a.valueHash),new sJ(e,s,n)}function sK(t,e,i){let a=new Map;for(let n of t.indexes)a.set(n.definition.name,new sL(n,new sl(e,i,n.valueHash)));return a}var sY=class extends Map{set(t,e){return 0===e.length?this:super.set(t,e)}};async function s$(t,e,i,a,n){let s=new sY;if(!a.shouldComputeDiffs())return s;let r=new sl(i,n,t.valueHash),l=new sl(i,n,e.valueHash),o=await sV(r,l);return s.set("",o),await sX(t,e,i,s,a,n),s}async function sX(t,e,i,a,n,s){let r=sK(t,i,s),l=sK(e,i,s);for(let[t,e]of r){if(!n.shouldComputeDiffsForIndex(t))continue;let i=l.get(t);if(void 0!==i){ah(i!==e);let n=await sV(e.map,i.map);l.delete(t),a.set(t,n)}else{let i=await su(e.map,"del");a.set(t,i)}}for(let[t,e]of l){if(!n.shouldComputeDiffsForIndex(t))continue;let i=await su(e.map,"add");a.set(t,i)}}var sQ=(tn=new WeakMap,ts=new WeakMap,tr=new WeakMap,tl=new WeakMap,to=new WeakMap,th=new WeakSet,class extends sJ{async put(t,e,i){if(1===(0,iJ._)(this,tr).type)throw Error("Not allowed");let a=sU(()=>this.map.get(e));await s2(t,this.indexes,e,a,i),await this.map.put(e,i)}getMutationID(){return sp((0,iJ._)(this,tl),(0,iJ._)(this,tn),(0,iJ._)(this,tr))}async del(t,e){if(1===(0,iJ._)(this,tr).type)throw Error("Not allowed");let i=sU(()=>this.map.get(e));return void 0!==i&&await s2(t,this.indexes,e,i,void 0),this.map.del(e)}async clear(){if(1===(0,iJ._)(this,tr).type)throw Error("Not allowed");await this.map.clear();let t=[];for(let e of this.indexes.values())t.push(e.clear());await Promise.all(t)}async putCommit(){var t,e;let i=await this.map.flush(),a=[];for(let t of this.indexes.values()){let e=await t.flush(),i={definition:t.meta.definition,valueHash:e};a.push(i)}let n,s=(0,iJ._)(this,tr);switch(s.type){case 2:{let{basisHash:t,mutationID:e,mutatorName:r,mutatorArgsJSON:l,originalHash:o,timestamp:h}=s;n=sP((0,iJ._)(this,tn).createChunk,sO({type:2,basisHash:t,mutationID:e,mutatorName:r,mutatorArgsJSON:l,originalHash:o,timestamp:h},i,a));break}case 4:{ah((0,iJ._)(this,to)>=5);let{basisHash:r,mutationID:l,mutatorName:o,mutatorArgsJSON:h,originalHash:u,timestamp:c}=s;t=(0,iJ._)(this,tn).createChunk,e=await sg(r,(0,iJ._)(this,tn)),n=sP(t,sO({type:4,basisHash:r,baseSnapshotHash:e,mutationID:l,mutatorName:o,mutatorArgsJSON:h,originalHash:u,timestamp:c,clientID:(0,iJ._)(this,tl)},i,a));break}case 3:{ah(4>=(0,iJ._)(this,to));let{basisHash:t,lastMutationID:e,cookieJSON:r}=s;n=sP((0,iJ._)(this,tn).createChunk,sO({type:3,basisHash:t,lastMutationID:e,cookieJSON:r},i,a));break}case 5:{ah((0,iJ._)(this,to)>5);let{basisHash:t,lastMutationIDs:e,cookieJSON:r}=s;n=sP((0,iJ._)(this,tn).createChunk,sN(t,e,r,i,a));break}case 1:{let{basisHash:t,lastMutationID:e}=s;if(void 0!==(0,iJ._)(this,ts)){if(await (0,iJ._)(this,ts).getMutationID((0,iJ._)(this,tl),(0,iJ._)(this,tn))!==e)throw Error("Index change must not change mutationID");if((0,iJ._)(this,ts).valueHash!==i)throw Error("Index change must not change valueHash")}n=sP((0,iJ._)(this,tn).createChunk,sO({type:1,basisHash:t,lastMutationID:e},i,a))}}return await (0,iJ._)(this,tn).putChunk(n.chunk),n}async commit(t){let e=(await this.putCommit()).chunk.hash;return await (0,iJ._)(this,tn).setHead(t,e),await (0,iJ._)(this,tn).commit(),e}async commitWithDiffs(t,e){let i=this.putCommit(),a=await (0,i$._)(this,th,oi).call(this,e),n=(await i).chunk.hash;return await (0,iJ._)(this,tn).setHead(t,n),await (0,iJ._)(this,tn).commit(),[n,a]}close(){(0,iJ._)(this,tn).release()}constructor(t,e,i,a,n,s,r){super(t,e,n),(0,iX._)(this,th),(0,iB._)(this,tn,{writable:!0,value:void 0}),(0,iB._)(this,ts,{writable:!0,value:void 0}),(0,iB._)(this,tr,{writable:!0,value:void 0}),(0,iB._)(this,tl,{writable:!0,value:void 0}),(0,iB._)(this,to,{writable:!0,value:void 0}),(0,iK._)(this,tn,t),(0,iK._)(this,ts,i),(0,iK._)(this,tr,a),(0,iK._)(this,tl,s),(0,iK._)(this,to,r),void 0===i?ah(a.basisHash===nr):ah(a.basisHash===i.chunk.hash)}});async function sZ(t,e,i,a,n,s,r,l){let o=await sS(t,n),h=new sj(n,l,o.valueHash),u=await o.getNextMutationID(r,n),c=s4(o,n,l);return new sQ(n,h,o,l>=5?{type:4,basisHash:t,baseSnapshotHash:await sg(t,n),mutatorName:e,mutatorArgsJSON:i,mutationID:u,originalHash:a,timestamp:s,clientID:r}:{type:2,basisHash:t,mutatorName:e,mutatorArgsJSON:i,mutationID:u,originalHash:a,timestamp:s},c,r,l)}async function s0(t,e,i,a,n,s,r){ah(r<=4);let l=await sS(t,a),o=new sj(a,r,l.valueHash);return new sQ(a,o,l,{basisHash:t,type:3,lastMutationID:e,cookieJSON:i},n,s,r)}async function s1(t,e,i,a,n,s){let r=await sS(t,a),l=new sj(a,s,r.valueHash);return new sQ(a,l,r,{basisHash:t,type:5,lastMutationIDs:e,cookieJSON:i},s4(r,a,s),n,s)}async function s2(t,e,i,a,n){let s=[];for(let o of e.values()){let{keyPrefix:e}=o.meta.definition;if(!e||i.startsWith(e)){var r,l;let e=await a();void 0!==e&&s.push(sF(t,o.map,1,i,e,o.meta.definition.jsonPointer,null!==(r=o.meta.definition.allowEmpty)&&void 0!==r&&r)),void 0!==n&&s.push(sF(t,o.map,0,i,n,o.meta.definition.jsonPointer,null!==(l=o.meta.definition.allowEmpty)&&void 0!==l&&l))}}await Promise.all(s)}function s4(t,e,i){let a=new Map;for(let n of t.indexes)a.set(n.definition.name,new sq(n,new sj(e,i,n.valueHash)));return a}async function s5(t,e,i,a,n,s,r){let l=new sj(e,r);for await(let e of i.scan(a)){let i=e[0];if(!i.startsWith(a))break;await sF(t,l,0,i,e[1],n,s)}return l}var s3=a1.string(),s7=a1.string(),s6=nt({heartbeatTimestampMs:a1.number(),headHash:nh,mutationID:a1.number(),lastServerAckdMutationID:a1.number()}),s8=nt({heartbeatTimestampMs:a1.number(),headHash:nh,tempRefreshHash:nh.nullable(),clientGroupID:s3}),s9=nt({heartbeatTimestampMs:a1.number(),refreshHashes:ne(nh),persistHash:nh.nullable(),clientGroupID:s3});function rt(t){return void 0!==t.refreshHashes}function re(t){return void 0!==t.clientGroupID}var ri="clients",ra=a1.union(s6,s8,s9);function rn(t){a3(t,s6,void 0)}function rs(t){a3(t,s9,void 0)}async function rr(t){return rl(await t.getHead(ri),t)}async function rl(t,e){if(!t)return new Map;let i=await e.getChunk(t);return function(t){aw(t);let e=new Map;for(let i in t)if(ay(t,i)){let a=t[i];void 0!==a&&(a3(a,ra,void 0),e.set(i,a))}return e}(null==i?void 0:i.data)}var ro=class extends Error{constructor(t){super("Client state not found, id: ".concat(t)),(0,iQ._)(this,"name","ClientStateNotFoundError"),(0,iQ._)(this,"id",void 0),this.id=t}};async function rh(t,e){if(!await ru(t,e))throw new ro(t)}async function ru(t,e){return!!await rc(t,e)}async function rc(t,e){return(await rr(e)).get(t)}async function rd(t,e){let i=await rc(t,e);if(!i)throw new ro(t);return i}async function rw(t,e,i){let a,n,s=new Set(e);for(let[e,r]of(await nV(t))){if(!r.disabled&&nF(s,r.mutatorNames)&&nP(i,r.indexes))return{type:2,clientGroupID:e,headHash:r.headHash};let l=await sb(r.headHash,t);sE(l);let{cookieJSON:o}=l.meta;(void 0===a||aM(o,a)>0)&&(a=o,n=l)}return n?{type:1,snapshot:n}:{type:0}}async function rf(t,e){let i=await rp(t,e);if(i)return nT(i,e)}async function rp(t,e){let i=await rc(t,e);if(!(!i||!re(i)))return i.clientGroupID}async function r_(t,e,i){let a=await rr(i);return rv(new Map(a).set(t,e),i)}async function rv(t,e){let i=function(t,e){for(let i of t.values())rt(i)?(i.refreshHashes.forEach(e.assertValidHash),i.persistHash&&e.assertValidHash(i.persistHash)):(e.assertValidHash(i.headHash),re(i)&&i.tempRefreshHash&&e.assertValidHash(i.tempRefreshHash));return Object.fromEntries(t)}(t,e),a=e.createChunk(i,function(t){let e=[];for(let i of t.values())rt(i)?(e.push(...i.refreshHashes),i.persistHash&&e.push(i.persistHash)):(e.push(i.headHash),re(i)&&i.tempRefreshHash&&e.push(i.tempRefreshHash));return e}(t));return await e.putChunk(a),await e.setHead(ri,a.hash),a.hash}var rm="profileId",ry=(tu=new WeakMap,tc=new WeakSet,class{putDatabase(t){return(0,i$._)(this,tc,oa).call(this,{...t,lastOpenedTimestampMS:Date.now()})}putDatabaseForTesting(t){return(0,i$._)(this,tc,oa).call(this,t)}clearDatabases(){return nC((0,iJ._)(this,tu),t=>t.del("dbs"))}deleteDatabases(t){return nC((0,iJ._)(this,tu),async e=>{let i={...await rg(e)};for(let e of t)delete i[e];await e.put("dbs",i)})}getDatabases(){return nH((0,iJ._)(this,tu),rg)}close(){return(0,iJ._)(this,tu).close()}getProfileID(){return nC((0,iJ._)(this,tu),async t=>{let e=await t.get(rm);return void 0===e&&(e="p".concat(na().replace(/-/g,"")),await t.put(rm,e)),au(e),e})}constructor(t){(0,iX._)(this,tc),(0,iB._)(this,tu,{writable:!0,value:void 0}),(0,iK._)(this,tu,t("replicache-dbs-v0"))}});async function rg(t){let e=await t.get("dbs");return e||(e={}),function(t){for(let[e,i]of(aw(t),Object.entries(t)))au(e),aw(i),au(i.name),au(i.replicacheName),ac(i.replicacheFormatVersion),au(i.schemaVersion),void 0!==i.lastOpenedTimestampMS&&ac(i.lastOpenedTimestampMS),ah(e===i.name)}(e),e}async function rb(t,e,i,a){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:rI,s=Object.values(await t.getDatabases()),r=(await Promise.all(s.map(async t=>[t.name,await rD(t,e,i,a,n)]))).filter(t=>t[1]).map(t=>t[0]),{errors:l}=await rM(t,r);if(l.length)throw l[0]}async function rk(t,e){await new Promise((e,i)=>{let a=indexedDB.deleteDatabase(t);a.onsuccess=()=>e(),a.onerror=()=>i(a.error)}),await e.deleteDatabases([t])}async function rM(t,e){let i=await Promise.allSettled(e.map(async e=>(await rk(e,t),e))),a=[],n=[];for(let t of i)"fulfilled"===t.status?a.push(t.value):n.push(t.reason);return{dropped:a,errors:n}}function rI(t){return new nk(new aL(t),nl,no)}async function rD(t,e,i,a,n){if(t.replicacheFormatVersion>7)return!1;if(void 0!==t.lastOpenedTimestampMS){let s=t.replicacheFormatVersion>=5;return!(e-t.lastOpenedTimestampMS<(s?a:i))&&(!s||(ah(5===t.replicacheFormatVersion||6===t.replicacheFormatVersion||7===t.replicacheFormatVersion),!await rS(n(t.name))))}let s=n(t.name),r=await nH(s,rr);return await s.close(),function(t,e,i){for(let a of t.values())if(e-a.heartbeatTimestampMs<i)return!1;return!0}(r,e,i)}async function rS(t){for(let e of(await nH(t,nV)).values())if(nz(e))return!0;return!1}var rW=(td=new WeakMap,tw=new WeakMap,tf=new WeakMap,tp=new WeakMap,t_=new WeakMap,tv=new WeakSet,tm=new WeakSet,class{waitForVisible(){return(0,i$._)(this,tm,os).call(this,"visible")}waitForHidden(){return(0,i$._)(this,tm,os).call(this,"hidden")}constructor(t,e,i){(0,iX._)(this,tv),(0,iX._)(this,tm),(0,iB._)(this,td,{writable:!0,value:void 0}),(0,iB._)(this,tw,{writable:!0,value:void 0}),(0,iB._)(this,tf,{writable:!0,value:0}),(0,iQ._)(this,"visibilityState",void 0),(0,iB._)(this,tp,{writable:!0,value:new Set}),(0,iB._)(this,t_,{writable:!0,value:()=>{"visible"===(0,iJ._)(this,td).visibilityState?(clearTimeout((0,iJ._)(this,tf)),(0,i$._)(this,tv,on).call(this,"visible")):(0,iK._)(this,tf,setTimeout(()=>{(0,i$._)(this,tv,on).call(this,"hidden")},(0,iJ._)(this,tw)))}}),(0,iK._)(this,td,t),(0,iK._)(this,tw,e),this.visibilityState=t.visibilityState,(0,iJ._)(this,td).addEventListener("visibilitychange",(0,iJ._)(this,t_),{signal:i})}}),rH=Promise.resolve(),rx=new Promise(()=>{}),rC=class{waitForVisible(){return rH}waitForHidden(){return rx}constructor(){(0,iQ._)(this,"visibilityState","visible")}};function rE(){return"u">typeof document?document:void 0}var rN=class{get maxDelayMs(){return this.rep.requestOptions.maxDelayMs}get minDelayMs(){return this.rep.requestOptions.minDelayMs}constructor(t,e){(0,iQ._)(this,"rep",void 0),(0,iQ._)(this,"invokeSend",void 0),(0,iQ._)(this,"maxConnections",1),this.rep=t,this.invokeSend=e}},rP=class extends rN{get watchdogTimer(){return this.rep.pullInterval}constructor(...t){super(...t),(0,iQ._)(this,"debounceDelay",0)}},rR=class extends rN{get debounceDelay(){return this.rep.pushDelay}constructor(...t){super(...t),(0,iQ._)(this,"watchdogTimer",null)}},rO=(ty=new WeakMap,tg=new WeakMap,tb=new WeakMap,tk=new WeakMap,tM=new WeakMap,tI=new WeakMap,tD=new WeakMap,tS=new WeakMap,tW=new WeakMap,tH=new WeakSet,tx=new WeakSet,class{close(){(0,iK._)(this,tM,!0),(0,iJ._)(this,tI)>0&&(0,iJ._)(this,tb).resolve({error:rA()})}async send(t){var e,i,a;if((0,iJ._)(this,tM))return{error:rA()};(0,iY._)(this,tI).value++,null===(e=(i=(0,iJ._)(this,tD)).debug)||void 0===e||e.call(i,"send",t),t?(0,iJ._)(this,tg).resolve():await (null===(a=(0,iJ._)(this,tS))||void 0===a?void 0:a.waitForVisible()),(0,iJ._)(this,ty).resolve();let n=await (0,iJ._)(this,tb).promise;return(0,iY._)(this,tI).value--,n}async run(){let t=[],e=(0,i0.U)(),i,a=0,n=(0,iJ._)(this,tk),{debug:s}=(0,iJ._)(this,tD),r=0;null==s||s("Starting connection loop");let l=t=>Promise.race([(0,iJ._)(this,tg).promise,aZ(t)]);for(;!(0,iJ._)(this,tM);){null==s||s(rV(t)?"Last request failed. Trying again":"Waiting for a send");let o=[(0,iJ._)(this,ty).promise],h=n.watchdogTimer;if(null!==h&&o.push(aZ(h)),await Promise.race(o),(0,iJ._)(this,tM)||(null==s||s("Waiting for debounce"),await l(n.debounceDelay),(0,iJ._)(this,tM)))break;if(null==s||s("debounced"),(0,iK._)(this,ty,(0,i0.U)()),a>=n.maxConnections){if(null==s||s("Too many request in flight. Waiting until one finishes..."),await (0,i$._)(this,tx,ol).call(this),(0,iJ._)(this,tM))break;null==s||s("...finished")}a>0||rV(t)?(r=function(t,e,i){let{length:a}=i;if(0===a)return t;let{ok:n}=i[i.length-1],{maxConnections:s,minDelayMs:r}=e;if(!n)return 0===t?r:2*t;if(a>1){let t=i[i.length-2];for(;i.length>9;)i.shift();if(n&&!t.ok)return r}return function(t){t.sort();let{length:e}=t,i=e>>1;return e%2==1?t[i]:(t[i-1]+t[i])/2}(i.filter(t=>{let{ok:e}=t;return e}).map(t=>{let{duration:e}=t;return e}))/s|0}(r,n,t),null==s||s(rV(t)?"Last connection errored. Sleeping for":"More than one outstanding connection ("+a+"). Sleeping for",r,"ms")):r=0;let u=Math.min(n.maxDelayMs,Math.max(n.minDelayMs,r));if(void 0!==i){let t=Date.now()-i;if(u>t&&(await Promise.race([l(u-t),e.promise]),(0,iJ._)(this,tM)))break}a++,(async()=>{let r=Date.now(),l,o;try{i=r,null==s||s("Sending request"),(0,iK._)(this,tg,(0,i0.U)()),l=await n.invokeSend(),null==s||s("Send returned",l)}catch(t){null==s||s("Send failed",t),o=t,l=!1}if((0,iJ._)(this,tM)){null==s||s("Closed after invokeSend");return}null==s||s("Request done",{duration:Date.now()-r,ok:l}),t.push({duration:Date.now()-r,ok:l}),t.length>1&&!t[t.length-2].ok&&t[t.length-1].ok&&(e.resolve(),e=(0,i0.U)()),a--,(0,i$._)(this,tH,or).call(this);let h=(0,iJ._)(this,tb);(0,iK._)(this,tb,(0,i0.U)()),o?h.resolve({error:o}):h.resolve(void 0),l||(0,iJ._)(this,ty).resolve()})()}}constructor(t,e,i){(0,iX._)(this,tH),(0,iX._)(this,tx),(0,iB._)(this,ty,{writable:!0,value:(0,i0.U)()}),(0,iB._)(this,tg,{writable:!0,value:(0,i0.U)()}),(0,iB._)(this,tb,{writable:!0,value:(0,i0.U)()}),(0,iB._)(this,tk,{writable:!0,value:void 0}),(0,iB._)(this,tM,{writable:!0,value:!1}),(0,iB._)(this,tI,{writable:!0,value:0}),(0,iB._)(this,tD,{writable:!0,value:void 0}),(0,iB._)(this,tS,{writable:!0,value:void 0}),(0,iB._)(this,tW,{writable:!0,value:void 0}),(0,iK._)(this,tD,t),(0,iK._)(this,tk,e),(0,iK._)(this,tS,i),this.run()}});function rA(){return Error("Closed")}function rV(t){return t.length>0&&!t[t.length-1].ok}var rj=(tC=new WeakMap,tE=new WeakMap,tN=new WeakMap,tP=new WeakMap,tR=new WeakMap,class{async read(){let t=await (0,iJ._)(this,tC).read();return new rU((0,iJ._)(this,tE),this.t,this.n,(0,iJ._)(this,tN),t,(0,iJ._)(this,tR))}async write(){let t=await (0,iJ._)(this,tC).write();return new rL((0,iJ._)(this,tE),this.t,this.n,(0,iJ._)(this,tN),this.h,this.m,t,(0,iJ._)(this,tP),(0,iJ._)(this,tR))}close(){return aO}isCached(t){return void 0!==this.n.getWithoutUpdatingLRU(t)}withSuspendedSourceCacheEvictsAndDeletes(t){return this.n.withSuspendedEvictsAndDeletes(t)}constructor(t,e,i,a,n=ss){(0,iB._)(this,tC,{writable:!0,value:new i1.z}),(0,iB._)(this,tE,{writable:!0,value:new Map}),(0,iB._)(this,tN,{writable:!0,value:void 0}),(0,iB._)(this,tP,{writable:!0,value:void 0}),(0,iB._)(this,tR,{writable:!0,value:void 0}),(0,iQ._)(this,"t",new Map),(0,iQ._)(this,"n",void 0),(0,iQ._)(this,"h",new Map),(0,iQ._)(this,"m",new Map),this.n=new rq(e,n,this.h,this.m),(0,iK._)(this,tN,t),(0,iK._)(this,tP,i),(0,iK._)(this,tR,a)}}),rU=(tO=new WeakMap,tA=new WeakMap,tV=new WeakMap,class{isMemOnlyChunkHash(t){return this.t.has(t)}async hasChunk(t){return await this.getChunk(t)!==void 0}async getChunk(t){let e=this.t.get(t);if(void 0!==e)return e;let i=this.n.get(t);return void 0===i&&void 0!==(i=await (await this.y()).getChunk(t))&&this.n.put(i),i}mustGetChunk(t){return ng(this,t)}getHead(t){return Promise.resolve(this.u.get(t))}release(){var t;(0,iJ._)(this,tV)||((0,iJ._)(this,tA).call(this),null===(t=(0,iJ._)(this,tO))||void 0===t||t.then(t=>t.release()).catch(t=>{}),(0,iK._)(this,tV,!0))}get closed(){return(0,iJ._)(this,tV)}y(){return(0,iJ._)(this,tO)||(0,iK._)(this,tO,this.f.read()),(0,iJ._)(this,tO)}constructor(t,e,i,a,n,s){(0,iQ._)(this,"u",void 0),(0,iQ._)(this,"t",void 0),(0,iQ._)(this,"n",void 0),(0,iQ._)(this,"f",void 0),(0,iB._)(this,tO,{writable:!0,value:void 0}),(0,iB._)(this,tA,{writable:!0,value:void 0}),(0,iB._)(this,tV,{writable:!0,value:!1}),(0,iQ._)(this,"assertValidHash",void 0),this.u=t,this.t=e,this.n=i,this.f=a,(0,iK._)(this,tA,n),this.assertValidHash=s}}),rL=(tj=new WeakMap,tU=new WeakMap,tL=new WeakMap,tq=new WeakMap,tF=new WeakSet,class extends rU{putChunk(t,e){let{hash:i,meta:a}=t;if(this.assertValidHash(i),a.length>0)for(let t of a)this.assertValidHash(t);return(0,iJ._)(this,tq).has(i)||this.isMemOnlyChunkHash(i)?this.r.set(i,t):this.s.set(i,{chunk:t,size:null!=e?e:-1}),aO}async setHead(t,e){await (0,i$._)(this,tF,oo).call(this,t,e)}async removeHead(t){await (0,i$._)(this,tF,oo).call(this,t,void 0)}isMemOnlyChunkHash(t){return this.r.has(t)||super.isMemOnlyChunkHash(t)}async getChunk(t){let e=this.r.get(t);if(void 0!==e)return e;let i=this.t.get(t);if(void 0!==i)return i;let a=this.s.get(t);if(void 0!==a)return a.chunk;let n=this.n.get(t);return void 0===n&&void 0!==(n=await (await this.y()).getChunk(t))&&this.s.set(n.hash,{chunk:n,size:-1}),n}getHead(t){let e=this.i.get(t);return e?Promise.resolve(e.new):super.getHead(t)}async commit(){let t=new Set(nQ(this.r.keys(),this.s.keys())),e=await nw(this.i.values(),t,this);for(let[t,i]of e)if(this.isMemOnlyChunkHash(t)){if(0===i)(0,iJ._)(this,tj).delete(t),this.t.delete(t),(0,iJ._)(this,tU).delete(t);else{(0,iJ._)(this,tj).set(t,i);let e=this.r.get(t);e&&((0,iJ._)(this,tU).set(t,e.meta),this.t.set(t,e))}e.delete(t)}for(let[t,i]of(this.n.updateForCommit(this.s,e),this.i))i.new?this.u.set(t,i.new):this.u.delete(t);this.r.clear(),this.s.clear(),this.i.clear(),this.release()}getRefCount(t){return(0,iJ._)(this,tj).get(t)}getRefs(t){let e=this.r.get(t);if(e)return e.meta;let i=this.t.get(t);if(i)return i.meta;let a=this.s.get(t);return void 0!==a?a.chunk.meta:(0,iJ._)(this,tU).get(t)}areRefsCounted(t){return(0,iJ._)(this,tU).has(t)}chunksPersisted(t){let e=[];for(let i of t){let t=this.t.get(i);t&&(this.t.delete(i),e.push(t))}this.n.persisted(e)}constructor(t,e,i,a,n,s,r,l,o){super(t,e,i,a,r,o),(0,iX._)(this,tF),(0,iB._)(this,tj,{writable:!0,value:void 0}),(0,iB._)(this,tU,{writable:!0,value:void 0}),(0,iB._)(this,tL,{writable:!0,value:void 0}),(0,iQ._)(this,"i",new Map),(0,iQ._)(this,"r",new Map),(0,iQ._)(this,"s",new Map),(0,iB._)(this,tq,{writable:!0,value:new Set}),(0,iQ._)(this,"createChunk",(t,e)=>{let i=new nu((0,iJ._)(this,tL)(),t,e);return(0,iJ._)(this,tq).add(i.hash),i}),(0,iK._)(this,tj,n),(0,iK._)(this,tU,s),(0,iK._)(this,tL,l)}}),rq=(tT=new WeakMap,tz=new WeakMap,tG=new WeakMap,tJ=new WeakMap,tB=new WeakMap,tK=new WeakMap,tY=new WeakMap,t$=new WeakSet,tX=new WeakSet,tQ=new WeakSet,tZ=new WeakSet,class{get(t){let e=this.cacheEntries.get(t);return e&&(this.cacheEntries.delete(t),this.cacheEntries.set(t,e)),null==e?void 0:e.chunk}getWithoutUpdatingLRU(t){var e;return null===(e=this.cacheEntries.get(t))||void 0===e?void 0:e.chunk}put(t){let{hash:e}=t,i=this.cacheEntries.get(e);if(i){this.cacheEntries.delete(e),this.cacheEntries.set(e,i);return}let a=(0,iJ._)(this,tG).get(e);if(!(void 0===a||a<1)&&(0,i$._)(this,tX,ou).call(this,t)){if(!(0,iJ._)(this,tJ).has(e)){for(let e of t.meta)(0,iJ._)(this,tG).set(e,((0,iJ._)(this,tG).get(e)||0)+1);(0,iJ._)(this,tJ).set(e,t.meta)}(0,i$._)(this,t$,oh).call(this)}}updateForCommit(t,e){for(let[i,a]of e)if(0===a)(0,iJ._)(this,tK)?((0,iJ._)(this,tG).set(i,0),(0,iJ._)(this,tY).push(i)):(0,i$._)(this,tZ,od).call(this,i);else{(0,iJ._)(this,tG).set(i,a);let e=t.get(i);if(e){let{chunk:t,size:a}=e,n=this.cacheEntries.get(i);n?(this.cacheEntries.delete(i),this.cacheEntries.set(i,n)):((0,i$._)(this,tX,ou).call(this,t,-1!==a?a:void 0),(0,iJ._)(this,tJ).set(i,t.meta))}}(0,i$._)(this,t$,oh).call(this)}persisted(t){for(let e of t)(0,i$._)(this,tX,ou).call(this,e);(0,i$._)(this,t$,oh).call(this)}async withSuspendedEvictsAndDeletes(t){(0,iK._)(this,tK,!0);try{return await t()}finally{for(let t of((0,iK._)(this,tK,!1),(0,iJ._)(this,tY)))0===(0,iJ._)(this,tG).get(t)&&(0,i$._)(this,tZ,od).call(this,t);(0,i$._)(this,t$,oh).call(this)}}constructor(t,e,i,a){(0,iX._)(this,t$),(0,iX._)(this,tX),(0,iX._)(this,tQ),(0,iX._)(this,tZ),(0,iB._)(this,tT,{writable:!0,value:void 0}),(0,iB._)(this,tz,{writable:!0,value:void 0}),(0,iB._)(this,tG,{writable:!0,value:void 0}),(0,iB._)(this,tJ,{writable:!0,value:void 0}),(0,iB._)(this,tB,{writable:!0,value:0}),(0,iB._)(this,tK,{writable:!0,value:!1}),(0,iB._)(this,tY,{writable:!0,value:[]}),(0,iQ._)(this,"cacheEntries",new Map),(0,iK._)(this,tT,t),(0,iK._)(this,tz,e),(0,iK._)(this,tG,i),(0,iK._)(this,tJ,a)}});function rF(t){return void 0!==t.indexName}function rT(t){return"string"==typeof t?[t]:t}var rz=class extends Error{constructor(){super("Transaction is closed")}};function rG(t){if(t.closed)throw new rz}function rJ(t){return t.closed?Promise.reject(new rz):void 0}var rB=(t0=new WeakMap,t1=new WeakMap,t2=new WeakMap,t4=new WeakMap,t5=new WeakSet,n=Symbol.asyncIterator,class{[n](){return this.values()}values(){return new rK((0,i$._)(this,t5,ow).call(this,t=>t[1]))}keys(){return new rK((0,i$._)(this,t5,ow).call(this,t=>t[0]))}entries(){return new rK((0,i$._)(this,t5,ow).call(this,t=>[t[0],t[1]]))}toArray(){return this.values().toArray()}constructor(t,e,i,a){(0,iX._)(this,t5),(0,iB._)(this,t0,{writable:!0,value:void 0}),(0,iB._)(this,t1,{writable:!0,value:void 0}),(0,iB._)(this,t2,{writable:!0,value:void 0}),(0,iB._)(this,t4,{writable:!0,value:void 0}),(0,iK._)(this,t0,t),(0,iK._)(this,t1,e),(0,iK._)(this,t2,i),(0,iK._)(this,t4,a)}}),rK=(t3=new WeakMap,s=Symbol.asyncIterator,class{next(){return(0,iJ._)(this,t3).next()}[s](){return(0,iJ._)(this,t3)[Symbol.asyncIterator]()}toArray(){return sA((0,iJ._)(this,t3))}constructor(t){(0,iB._)(this,t3,{writable:!0,value:void 0}),(0,iK._)(this,t3,t)}});async function*rY(t,e,i,a,n){var s;rG(a);let{limit:r=1/0}=i,{prefix:l=""}=i,o=null===(s=i.start)||void 0===s?void 0:s.exclusive,h=rF(i);for await(let a of e){let e=a[0];if(!(h?e[0]:e).startsWith(l))return;if(o){if(o=!0,h){if(function(t,e){let[i,a]=rT(e),[n,s]=rT(t);return n===i&&(void 0===a||s===a)}(e,i.start.key))continue}else if(e===i.start.key)continue}if(yield t(a),0==--r&&!h){n(e);return}}}var r$=0,rX=class{get(t){return rJ(this.dbtx)||this.dbtx.get(t)}async has(t){return rG(this.dbtx),this.dbtx.has(t)}async isEmpty(){return rG(this.dbtx),this.dbtx.isEmpty()}scan(t){return rZ(t,this.dbtx,rQ)}constructor(t,e,i,a="openReadTransaction"){(0,iQ._)(this,"clientID",void 0),(0,iQ._)(this,"dbtx",void 0),(0,iQ._)(this,"d",void 0),(0,iQ._)(this,"location",void 0),(0,iQ._)(this,"environment",void 0),this.clientID=t,this.dbtx=e,this.d=i.withContext(a).withContext("txid",r$++),this.environment="client",this.location="client"}};function rQ(t){}function rZ(t,e,i){return new rB(t&&rF(t)?r2(e,t):e.map.scan(function(t){if(!t)return"";let{prefix:e="",start:i}=t;return i&&nJ(i.key,e)>0?i.key:e}(t)),null!=t?t:{},e,i)}var r0=(t7=new WeakMap,t6=new WeakMap,t8=new WeakMap,class{get environment(){return(0,iJ._)(this,t8).location}get location(){return(0,iJ._)(this,t8).location}get clientID(){return(0,iJ._)(this,t8).clientID}isEmpty(){return(0,iJ._)(this,t6).push({options:{}}),(0,iJ._)(this,t8).isEmpty()}get(t){return(0,iJ._)(this,t7).add(t),(0,iJ._)(this,t8).get(t)}has(t){return(0,iJ._)(this,t7).add(t),(0,iJ._)(this,t8).has(t)}scan(t){let e,i,a,n;let s={options:t?(t.start&&({key:e,exclusive:i}=t.start,t.indexName?"string"==typeof e?n=e:(n=e[0],a=e[1]):a=e),{prefix:t.prefix,startSecondaryKey:n,startKey:a,startExclusive:i,limit:t.limit,indexName:t.indexName}):{},inclusiveLimitKey:void 0};return(0,iJ._)(this,t6).push(s),rZ(t,(0,iJ._)(this,t8).dbtx,t=>{s.inclusiveLimitKey=t})}get keys(){return(0,iJ._)(this,t7)}get scans(){return(0,iJ._)(this,t6)}constructor(t){(0,iB._)(this,t7,{writable:!0,value:new Set}),(0,iB._)(this,t6,{writable:!0,value:[]}),(0,iB._)(this,t8,{writable:!0,value:void 0}),(0,iK._)(this,t8,t)}}),r1=class extends rX{put(t,e){return this.set(t,e)}async set(t,e){rG(this.dbtx),await this.dbtx.put(this.d,t,e)}del(t){var e;return null!==(e=rJ(this.dbtx))&&void 0!==e?e:this.dbtx.del(this.d,t)}constructor(t,e,i,a,n,s="openWriteTransaction"){super(t,a,n,s),(0,iQ._)(this,"reason",void 0),(0,iQ._)(this,"mutationID",void 0),this.mutationID=e,this.reason=i}};async function*r2(t,e){for await(let i of t.getMapForIndex(e.indexName).scan(function(t){let{prefix:e,start:i}=t,a="";if(void 0!==e&&(a=sz(e,void 0)),!i)return a;let{key:n}=i,[s,r]=rT(n),l=sz(s,r);return nJ(l,a)>0?l:a}(e)))yield[sG(i[0]),i[1]]}async function r4(t,e,i,a,n,s,r){var l;let o=t.meta,h=o.mutatorName;sH(o)&&ah(o.clientID===s,"mutationClientID must match clientID of LocalMeta");let u=a[h];u||null===(l=n.error)||void 0===l||l.call(n,"Cannot rebase unknown mutator ".concat(h));let c=o.mutatorArgsJSON,d=await (await sS(i,e)).getNextMutationID(s,e);if(d!==o.mutationID)throw Error("Inconsistent mutation ID: original: ".concat(o.mutationID,", next: ").concat(d," - mutationClientID: ").concat(s," mutatorName: ").concat(h));r>=5&&(au(o.clientID),function(t){if(ac(t.mutationID),au(t.mutatorName),!t.mutatorName)throw Error("Missing mutator name");t.mutatorArgsJSON,null!==t.originalHash&&no(t.originalHash),ac(t.timestamp)}(o));let w=await sZ(i,h,c,t.chunk.hash,e,o.timestamp,s,r),f=new r1(s,await w.getMutationID(),"rebase",w,n);return await (u||(async()=>{}))(f,c),w}async function r5(t,e,i,a,n,s,r){return(await r4(t,e,i,a,n,s,r)).putCommit()}async function r3(t,e,i,a,n,s,r,l){return(await r4(t,e,i,n,s,r,l)).commit(a)}var r7=new WeakSet;function r6(t){return t instanceof Error?t:Error(String(t))}async function r8(t,e,i){for(let a of i)switch(a.op){case"put":await e.put(t,a.key,a.value);break;case"del":await e.del(t,a.key);break;case"clear":await e.clear()}}var r9=class extends Error{constructor(t){super("Failed to pull"),(0,iQ._)(this,"name","PullError"),(0,iQ._)(this,"causedBy",void 0),this.causedBy=t}},lt="sync";async function le(t,e,i,a,n,s,r,l){let o=!(arguments.length>8)||void 0===arguments[8]||arguments[8],[h,u]=await nH(s,async t=>{let i=await t.getHead(sc);if(!i)throw Error("Internal no main head found");let a=await sb(i,t),n=a.meta.cookieJSON;return[await a.getMutationID(e,t),n]}),{response:c,httpRequestInfo:d}=await la(l,a,{profileID:t,clientID:e,cookie:u,lastMutationID:h,pullVersion:0,schemaVersion:i},n);if(!c)return{httpRequestInfo:d,syncHead:nr};if(!o||aS(c))return{httpRequestInfo:d,pullResponse:c,syncHead:nr};let w=await nx(s,async t=>{var i;let a;ah(r<=4);let n=await t.getHead(sc);if(void 0===n)throw Error("Main head disappeared");let s=await sb(n,t),[o,h]=sM(s,e);if(!ag(u,h))return{type:2};if(c.lastMutationID<o)throw Error(ln("lastMutationID",c.lastMutationID,o));let d=null!==(i=c.cookie)&&void 0!==i?i:null;if(0===c.patch.length&&c.lastMutationID===o&&ag(d,h))return{type:1};for(let i of(await sD(n,t)))if(await i.getMutationID(e,t)<=c.lastMutationID){a=i;break}if(!a)throw Error("Internal invalid chain");let w=await s0(s.chunk.hash,c.lastMutationID,d,t,s4(a,t,r),e,r);await r8(l,w,c.patch);let f=new sl(t,r,a.valueHash);for await(let t of w.map.diff(f))await s2(l,w.indexes,t.key,()=>Promise.resolve(t.oldValue),t.newValue);return{type:0,syncHead:await w.commit(lt)}});if(2===w.type)throw Error("Overlapping sync");return{httpRequestInfo:d,pullResponse:c,syncHead:0===w.type?w.syncHead:nr}}async function li(t,e,i,a,n,s,r,l,o){let h=!(arguments.length>9)||void 0===arguments[9]||arguments[9],u=await nH(r,async t=>{let e=await t.getHead(sc);if(!e)throw Error("Internal no main head found");let i=(await sb(e,t)).meta;return sC(i),i.cookieJSON}),{response:c,httpRequestInfo:d}=await la(o,n,{profileID:t,clientGroupID:i,cookie:u,pullVersion:1,schemaVersion:a},s);if(!c)return{httpRequestInfo:d,syncHead:nr};if(!h||aS(c))return{httpRequestInfo:d,pullResponse:c,syncHead:nr};let w=await ls(o,r,u,c,e,l);return{httpRequestInfo:d,pullResponse:c,syncHead:0===w.type?w.syncHead:nr}}async function la(t,e,i,a){var n,s,r,l;null===(n=t.debug)||void 0===n||n.call(t,"Starting pull...");let o=Date.now();try{let n=await e(i,a);return null===(s=t.debug)||void 0===s||s.call(t,"...Pull ".concat(n.response?"complete":"failed"," in "),Date.now()-o,"ms"),1===i.pullVersion?(aw(n),ax(n.httpRequestInfo),void 0!==n.response&&(r=n.response,aw(r),aW(r)||aH(r)||(void 0!==r.cookie&&function(t){if(!(null===t||"string"==typeof t||"number"==typeof t)&&(aw(t),function(t){for(let e in t)ay(t,e)&&t[e]}(t),!("string"==typeof t.order||"number"==typeof t.order)))throw Error("Invalid cookie")}(r.cookie),function(t){for(let[e,i]of(aw(t),Object.entries(t)))au(e),ac(i)}(r.lastMutationIDChanges),aC(r.patch)))):(aw(n),ax(n.httpRequestInfo),void 0!==n.response&&(l=n.response,aw(l),aW(l)||aH(l)||(void 0!==l.cookie&&l.cookie,ac(l.lastMutationID),aC(l.patch)))),n}catch(t){throw new r9(r6(t))}}function ln(t,e,i){return"Received ".concat(t," ").concat(e," is < than last snapshot ").concat(t," ").concat(i,"; ignoring client view")}function ls(t,e,i,a,n,s){return nx(e,async e=>{var r;let l=await e.getHead(sc);if(void 0===l)throw Error("Main head disappeared");let o=await sb(l,e),h=o.meta;sC(h);let u=h.cookieJSON;if(!ag(i,u))return null===(r=t.debug)||void 0===r||r.call(t,"handlePullResponse: cookie mismatch, pull response is not applicable"),{type:2};for(let[t,e]of Object.entries(a.lastMutationIDChanges)){let i=h.lastMutationIDs[t];if(void 0!==i&&e<i)throw Error(ln("".concat(t," lastMutationID"),e,i))}let c=a.cookie;if(0>aM(c,u))throw Error(ln("cookie",c,u));if(0===a.patch.length&&ag(c,u)&&!function(t,e){for(let[i,a]of Object.entries(t))if(a!==e[i])return!0;return!1}(a.lastMutationIDChanges,h.lastMutationIDs))return{type:1};let d=await s1(o.chunk.hash,{...h.lastMutationIDs,...a.lastMutationIDChanges},c,e,n,s);return await r8(t,d,a.patch),{type:0,syncHead:await d.commit(lt)}})}var lr=a1.unknown().chain(t=>i2.ok(t)),ll=class extends Error{constructor(t){super("Failed to push"),(0,iQ._)(this,"name","PushError"),(0,iQ._)(this,"causedBy",void 0),this.causedBy=t}},lo=nt({id:a1.number(),name:a1.string(),args:lr,timestamp:a1.number()}),lh=nt({id:a1.number(),name:a1.string(),args:lr,timestamp:a1.number(),clientID:s7});async function lu(t,e,i,a,n,s,r,l,o){var h,u,c,d;let w;let f=await nH(e,async t=>{let e=await t.getHead(sc);if(!e)throw Error("Internal no main head");return s_(e,t)});if(0===f.length)return;if(f.reverse(),1===o){let t=[];for(let e of f)if(sd(e))t.push({id:(c=e.meta).mutationID,name:c.mutatorName,args:c.mutatorArgsJSON,timestamp:c.timestamp,clientID:c.clientID});else throw Error("Internal non local pending commit");ah(n),w={profileID:a,clientGroupID:n,mutations:t,pushVersion:1,schemaVersion:l}}else{ah(0===o);let t=[];for(let e of f){if(2===e.meta.type)t.push({id:(d=e.meta).mutationID,name:d.mutatorName,args:d.mutatorArgsJSON,timestamp:d.timestamp});else throw Error("Internal non local pending commit")}w={profileID:a,clientID:s,mutations:t,pushVersion:0,schemaVersion:l}}null===(h=i.debug)||void 0===h||h.call(i,"Starting push...");let p=Date.now(),_=await lc(r,w,t);return null===(u=i.debug)||void 0===u||u.call(i,"...Push complete in ",Date.now()-p,"ms"),_}async function lc(t,e,i){try{var a;let n=await t(e,i);return aw(n),ax(n.httpRequestInfo),void 0!==n.response&&(a=n.response,aW(a)||ah(aH(a))),n}catch(t){throw new ll(r6(t))}}a1.object({pushVersion:a1.literal(0),schemaVersion:a1.string(),profileID:a1.string(),clientID:s7,mutations:a1.array(lo)}),a1.object({pushVersion:a1.literal(1),schemaVersion:a1.string(),profileID:a1.string(),clientGroupID:s3,mutations:a1.array(lh)});var ld=(t9=new WeakMap,et=new WeakMap,class{async recoverMutations(t,e,i,a,n,s){var r,l,o;let{lc:h,enableMutationRecovery:u,isPushDisabled:c,delegate:d}=(0,iJ._)(this,et);if(!u||(0,iJ._)(this,t9)||!d.online||d.closed||c())return!1;let w="Recovering mutations.";null===(r=h.debug)||void 0===r||r.call(h,"Start:",w);try{for(let r of((0,iK._)(this,t9,!0),await e,await l_(a,(0,iJ._)(this,et),i,t),Object.values(await n.getDatabases()))){if(d.closed)return null===(l=h.debug)||void 0===l||l.call(h,"Exiting early due to close:",w),!0;if(r.replicacheName===d.name&&r.name!==d.idbName)switch(r.replicacheFormatVersion){case 4:case 5:case 6:case 7:await lp(r,(0,iJ._)(this,et),void 0,s)}}}catch(t){lw(t,h,w,d)}finally{null===(o=h.debug)||void 0===o||o.call(h,"End:",w),(0,iK._)(this,t9,!1)}return!0}constructor(t){(0,iB._)(this,t9,{writable:!0,value:!1}),(0,iB._)(this,et,{writable:!0,value:void 0}),(0,iK._)(this,et,t)}});function lw(t,e,i,a){var n,s;a.closed?null===(n=e.debug)||void 0===n||n.call(e,"Mutation recovery error likely due to close during:\n".concat(i,"\nError:\n"),t):null===(s=e.error)||void 0===s||s.call(e,"Mutation recovery error during:\n".concat(i,"\nError:\n"),t)}async function lf(t,e,i,a,n,s){var r,l,o,h,u,c,d,w,f;ah(4===a.replicacheFormatVersion),rn(t);let{delegate:p,lc:_,wrapInOnlineCheck:v,wrapInReauthRetries:m,isPushDisabled:y,isPullDisabled:g}=n,b=p.clientID;if(b===e||t.lastServerAckdMutationID>=t.mutationID)return;let k="Recovering mutations for ".concat(e,".");null===(r=_.debug)||void 0===r||r.call(_,"Start:",k);let M=new rj(i,10485760,nd,no);try{if(await nC(M,e=>e.setHead(sc,t.headHash)),y()){null===(u=_.debug)||void 0===u||u.call(_,"Cannot recover mutations for client ".concat(e," because push is disabled."));return}let{pusher:n}=p,r="recoveringMutationsPush";if(!await v(async()=>{let{result:t}=await m(async(t,i)=>{a_(M);let s=await lu(t,M,i,await p.profileID,void 0,e,n,a.schemaVersion,0);return{result:s,httpRequestInfo:null==s?void 0:s.httpRequestInfo}},r,_);return!!t&&200===t.httpRequestInfo.httpStatusCode},r)){null===(c=_.debug)||void 0===c||c.call(_,"Failed to recover mutations for client ".concat(e," due to a push error."));return}if(g()){null===(d=_.debug)||void 0===d||d.call(_,"Cannot confirm mutations were recovered for client ".concat(e," because pull is disabled."));return}let{puller:f}=p,k="recoveringMutationsPull",I;if(!await v(async()=>{let{result:t}=await m(async(t,i)=>{let n=await le(await p.profileID,e,a.schemaVersion,f,t,M,s,i,!1);return{result:n,httpRequestInfo:n.httpRequestInfo}},k,_);return{pullResponse:I}=t,!!I&&200===t.httpRequestInfo.httpStatusCode},k)){null===(w=_.debug)||void 0===w||w.call(_,"Failed to recover mutations for client ".concat(e," due to a pull error."));return}return _.debug&&I&&(aW(I)?null===(l=_.debug)||void 0===l||l.call(_,"Client ".concat(b," cannot recover mutations for client ").concat(e,". The client no longer exists on the server.")):aH(I)?null===(o=_.debug)||void 0===o||o.call(_,"Version is not supported on the server. versionType: ".concat(I.versionType,". Cannot recover mutations for client ").concat(e,".")):null===(h=_.debug)||void 0===h||h.call(_,"Client ".concat(b," recovered mutations for client ").concat(e,".  Details"),{mutationID:t.mutationID,lastServerAckdMutationID:t.lastServerAckdMutationID,lastMutationID:I.lastMutationID})),await nC(i,async t=>{let i=await rr(t),a=i.get(e);if(!a)return i;rn(a);let n=async e=>(await rv(e,t),e);if(aW(I)||aH(I)){let t=new Map(i);return t.delete(e),n(t)}if(ah(I),a.lastServerAckdMutationID>=I.lastMutationID)return i;let s=new Map(i).set(e,{...a,lastServerAckdMutationID:I.lastMutationID});return n(s)})}catch(t){lw(t,_,k,p)}finally{await M.close(),null===(f=_.debug)||void 0===f||f.call(_,"End:",k)}}async function lp(t,e,i,a){let n=new nk(a(t.name),nl,no);try{await l_(t,e,n,i)}finally{await n.close()}}function l_(t,e,i,a){return t.replicacheFormatVersion>=5?lm(t,e,i):lv(t,e,i,a)}async function lv(t,e,i,a){var n,s,r;let{delegate:l,lc:o}=e,h="Recovering mutations from db ".concat(t.name,".");null===(n=o.debug)||void 0===n||n.call(o,"Start:",h);try{let n=nD(t.replicacheFormatVersion),s=a||await nH(i,t=>rr(t)),u=new Set;for(;s;){let a;for(let[c,d]of s){if(l.closed){null===(r=o.debug)||void 0===r||r.call(o,"Exiting early due to close:",h);return}if(!u.has(c)&&(u.add(c),a=await lf(d,c,i,t,e,n)))break}s=a}}catch(t){lw(t,o,h,l)}null===(s=o.debug)||void 0===s||s.call(o,"End:",h)}async function lm(t,e,i){var a,n,s;let{delegate:r,lc:l}=e,o="Recovering mutations from db ".concat(t.name,".");null===(a=l.debug)||void 0===a||a.call(l,"Start:",o);try{let a=nD(t.replicacheFormatVersion),n=await nH(i,t=>nV(t)),h=new Set;for(;n;){let u;for(let[c,d]of n){if(r.closed){null===(s=l.debug)||void 0===s||s.call(l,"Exiting early due to close:",o);return}if(!h.has(c)&&(h.add(c),u=await lg(d,c,i,t,e,a)))break}n=u}}catch(t){lw(t,l,o,r)}null===(n=l.debug)||void 0===n||n.call(l,"End:",o)}async function ly(t,e,i,a,n){var s,r;aW(a)?null===(s=t.debug)||void 0===s||s.call(t,"Client group ".concat(e," cannot recover mutations for client group ").concat(i,". The client group is unknown on the server. Marking it as disabled.")):aH(a)&&(null===(r=t.debug)||void 0===r||r.call(t,"Client group ".concat(e," cannot recover mutations for client group ").concat(i,". The client group's version is not supported on the server. versionType: ").concat(a.versionType,". Marking it as disabled."))),await nC(n,t=>nG(i,t))}async function lg(t,e,i,a,n,s){var r,l,o,h,u,c,d,w;ah(a.replicacheFormatVersion>=5);let{delegate:f,lc:p,wrapInOnlineCheck:_,wrapInReauthRetries:v,isPushDisabled:m,isPullDisabled:y}=n,g=await n.clientGroupIDPromise;if(a_(g),g===e)return;let b,k=!0;for(let[e,i]of Object.entries(t.mutationIDs))if(!t.lastServerAckdMutationIDs[e]||t.lastServerAckdMutationIDs[e]<i){b=e,k=!1;break}if(k)return;if(t.disabled){null===(l=p.debug)||void 0===l||l.call(p,"Not recovering mutations for client group ".concat(e," because group is disabled."));return}let M="Recovering mutations for client group ".concat(e,".");null===(r=p.debug)||void 0===r||r.call(p,"Start:",M);let I=new rj(i,10485760,nd,no);try{if(await nC(I,e=>e.setHead(sc,t.headHash)),m()){null===(h=p.debug)||void 0===h||h.call(p,"Cannot recover mutations for client group ".concat(e," because push is disabled."));return}let{pusher:n}=f,r="recoveringMutationsPush";if(!await _(async()=>{let{result:t}=await v(async(t,i)=>{ah(b),ah(I);let s=await lu(t,I,i,await f.profileID,e,b,n,a.schemaVersion,1);return{result:s,httpRequestInfo:null==s?void 0:s.httpRequestInfo}},r,p);if(!t)return!1;let s=t.response;return aW(s)||aH(s)?(await ly(p,g,e,s,i),!1):200===t.httpRequestInfo.httpStatusCode},r)){null===(u=p.debug)||void 0===u||u.call(p,"Failed to recover mutations for client ".concat(e," due to a push error."));return}if(y()){null===(c=p.debug)||void 0===c||c.call(p,"Cannot confirm mutations were recovered for client ".concat(e," because pull is disabled."));return}let{puller:l}=f,w="recoveringMutationsPull",k;if(!await _(async()=>{let{result:t}=await v(async(t,i)=>{ah(b);let n=await li(await f.profileID,b,e,a.schemaVersion,l,t,I,s,i,!1);return{result:n,httpRequestInfo:n.httpRequestInfo}},w,p),{pullResponse:n}=t;return aW(n)||aH(n)?(await ly(p,g,e,n,i),!1):!!n&&200===t.httpRequestInfo.httpStatusCode&&(k=n,!0)},w)){null===(d=p.debug)||void 0===d||d.call(p,"Failed to recover mutations for client ".concat(e," due to a pull error."));return}return ah(k),null===(o=p.debug)||void 0===o||o.call(p,"Client group ".concat(g," recovered mutations for client group ").concat(e,".  Details"),{mutationIDs:t.mutationIDs,lastServerAckdMutationIDs:t.lastServerAckdMutationIDs,lastMutationIDChanges:k.lastMutationIDChanges}),await nC(i,async t=>{var i;let a=await nV(t),n=a.get(e);if(!n)return a;ah(k);let s={},r=!1;for(let[t,e]of Object.entries(k.lastMutationIDChanges))(null!==(i=n.lastServerAckdMutationIDs[t])&&void 0!==i?i:0)<e&&(s[t]=e,r=!0);if(!r)return a;let l=new Map(a).set(e,{...n,lastServerAckdMutationIDs:{...n.lastServerAckdMutationIDs,...s}});return await nj(l,t),l})}catch(t){lw(t,p,M,f)}finally{await I.close(),null===(w=p.debug)||void 0===w||w.call(p,"End:",M)}}var lb=typeof BroadcastChannel>"u"?class{addEventListener(){}removeEventListener(){}dispatchEvent(){return!1}close(){}postMessage(){}constructor(t){_define_property(this,"name",void 0),_define_property(this,"onmessage",null),_define_property(this,"onmessageerror",null),this.name=t}}:BroadcastChannel;async function lk(t){let e=await nb(sc,t);return(await sv(e,t)).map(t=>({id:t.meta.mutationID,name:t.meta.mutatorName,args:t.meta.mutatorArgsJSON,clientID:t.meta.clientID})).reverse()}var lM=(ee=new WeakMap,ei=new WeakMap,class{async visit(t){if((0,iJ._)(this,ee).has(t))return;(0,iJ._)(this,ee).add(t);let e=await (0,iJ._)(this,ei).mustGetChunk(t);await this.visitChunk(e)}async visitChunk(t){await Promise.all(t.meta.map(t=>this.visit(t)))}constructor(t){(0,iB._)(this,ee,{writable:!0,value:new Set}),(0,iB._)(this,ei,{writable:!0,value:void 0}),(0,iK._)(this,ei,t)}}),lI=(ea=new WeakMap,en=new WeakMap,class extends lM{get gatheredChunks(){return(0,iJ._)(this,ea)}visit(t){return(0,iJ._)(this,en).isMemOnlyChunkHash(t)?super.visit(t):aO}visitChunk(t){return(0,iJ._)(this,ea).set(t.hash,t),super.visitChunk(t)}constructor(t){super(t),(0,iB._)(this,ea,{writable:!0,value:new Map}),(0,iB._)(this,en,{writable:!0,value:void 0}),(0,iK._)(this,en,t)}});async function lD(t,e,i,a,n,s,r){let l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:()=>Promise.resolve();if(s())return;let[o,h,u]=await nH(a,async t=>{await rh(e,t);let i=await rp(e,t);ah(i,"No main client group for clientID: ".concat(e));let[,a]=await lS(t,i),n=await a.getMutationID(e,t),s=await sk(a,t);return sE(s),[n,s,i]});if(s())return;let[c,d,w]=await nH(i,async t=>{let i,a=await sW(sc,t),n=await sm(a,{[e]:o||0},t),s=await sk(a,t);if(sE(s),sI(s,h)>0){await l();let e=s.chunk.hash,a=new lI(t);await a.visit(e),i=a.gatheredChunks}return[n,s,i]});if(s())return;let f=!1;await nC(a,async i=>{let[a,s]=await lS(i,u),l=s.chunk.hash,o={...a.mutationIDs},{lastServerAckdMutationIDs:h}=a;if(w){let u=await rd(e,i);rs(u);let c=await sk(s,i);if(sE(c),sI(d,c)>0){f=!0,await Promise.all(Array.from(w.values(),t=>i.putChunk(t))),await r_(e,{...u,persistHash:d.chunk.hash},i),l=d.chunk.hash;let s=await sv(a.headHash,i);o={...h=d.meta.lastMutationIDs},l=await lW(s,l,i,n,o,t,r)}}l=await lW(c,l,i,n,o,t,r);let p={...a,headHash:l,mutationIDs:o,lastServerAckdMutationIDs:h};await nU(u,p,i)}),w&&f&&await nC(i,t=>t.chunksPersisted([...w.keys()]))}async function lS(t,e){let i=await nT(e,t);return ah(i,"No client group for clientGroupID: ".concat(e)),[i,await sS(i.headHash,t)]}async function lW(t,e,i,a,n,s,r){for(let l=t.length-1;l>=0;l--){let o=t[l],{meta:h}=o,u=await sS(e,i);await o.getMutationID(h.clientID,i)>await u.getMutationID(h.clientID,i)&&(n[h.clientID]=h.mutationID,e=(await r5(o,i,e,a,s,h.clientID,r)).chunk.hash)}return e}var lH=(es=new WeakMap,er=new WeakMap,el=new WeakMap,eo=new WeakMap,eh=new WeakMap,class extends lM{get gatheredChunks(){return(0,iJ._)(this,es)}visit(t){return(0,iJ._)(this,er)>=(0,iJ._)(this,eo)||(0,iJ._)(this,el).isCached(t)?aO:super.visit(t)}visitChunk(t){if((0,iJ._)(this,er)<(0,iJ._)(this,eo)){let e=(0,iJ._)(this,eh).call(this,t);(0,iJ._)(this,es).set(t.hash,{chunk:t,size:e}),(0,iK._)(this,er,(0,iJ._)(this,er)+e)}return super.visitChunk(t)}constructor(t,e,i,a=ss){super(t),(0,iB._)(this,es,{writable:!0,value:new Map}),(0,iB._)(this,er,{writable:!0,value:0}),(0,iB._)(this,el,{writable:!0,value:void 0}),(0,iB._)(this,eo,{writable:!0,value:void 0}),(0,iB._)(this,eh,{writable:!0,value:void 0}),(0,iK._)(this,el,e),(0,iK._)(this,eo,i),(0,iK._)(this,eh,a)}});async function lx(t,e,i,a,n,s,r,l){if(r())return;let o=await nH(e,t=>sy(sc,t));sE(o);let h=await e.withSuspendedSourceCacheEvictsAndDeletes(async()=>{let h=await nC(i,async t=>{let i=await rf(a,t);if(!i)throw new ro(a);let n=i.headHash,s=await (await sS(n,t)).getMutationID(a,t),r=await rd(a,t);rs(r);let l=await sb(n,t);if(sE(l),lC(o,l,n))return;let h=new lH(t,e,5242880);await h.visit(n);let{gatheredChunks:u}=h,c=new Set(r.refreshHashes);c.add(n);let d={...r,refreshHashes:[...c]};return await r_(a,d,t),[n,l,s,u,r.refreshHashes]});if(r()||!h||(await aZ(300),r()))return{type:"aborted"};let[u,c,d,w,f]=h;return nC(e,async e=>{let i=await sW(sc,e),r=await sk(i,e);if(sE(r),lC(r,c,u))return{type:"aborted",refreshHashesForRevert:f};let o=await sm(i,{[a]:d},e),h=[];for(let{chunk:t,size:i}of w.values())h.push(e.putChunk(t,i));await Promise.all(h);let p=u;for(let i=o.length-1;i>=0;i--)p=(await r5(o[i],e,p,n,t,o[i].meta.clientID,l)).chunk.hash;let _=await sS(p,e),v=await s$(i,_,e,s,l);return await e.setHead(sc,p),{type:"complete",newMemdagHeadHash:p,diffs:v,newPerdagClientHeadHash:u}})});if(r())return;let u=t=>nC(i,async e=>{let i={...await rd(a,e),refreshHashes:t};await r_(a,i,e)});if("aborted"===h.type){h.refreshHashesForRevert&&await u(h.refreshHashesForRevert);return}return await u([h.newPerdagClientHeadHash]),[h.newMemdagHeadHash,h.diffs]}function lC(t,e,i){let a=sI(t,e);return a>0||0===a&&i===e.chunk.hash}function lE(t){return new Promise(e=>{"function"==typeof requestIdleCallback?requestIdleCallback(()=>e(),{timeout:t}):setTimeout(()=>e(),t)})}var lN=(eu=new WeakMap,ec=new WeakMap,ed=new WeakMap,ew=new WeakMap,ef=new WeakMap,ep=new WeakMap,e_=new WeakMap,ev=new WeakMap,em=new WeakMap,ey=new WeakSet,class{schedule(){return(0,iJ._)(this,ew).aborted?Promise.reject(new aX("Aborted")):((0,iJ._)(this,ep)||((0,iK._)(this,ep,(0,i0.U)()),(0,i$._)(this,ey,of).call(this)),(0,iJ._)(this,ep).promise)}constructor(t,e,i,a,n=lE){(0,iX._)(this,ey),(0,iB._)(this,eu,{writable:!0,value:void 0}),(0,iB._)(this,ec,{writable:!0,value:void 0}),(0,iB._)(this,ed,{writable:!0,value:void 0}),(0,iB._)(this,ew,{writable:!0,value:void 0}),(0,iB._)(this,ef,{writable:!0,value:void 0}),(0,iB._)(this,ep,{writable:!0,value:void 0}),(0,iB._)(this,e_,{writable:!0,value:void 0}),(0,iB._)(this,ev,{writable:!0,value:Promise.resolve()}),(0,iB._)(this,em,{writable:!0,value:Promise.resolve()}),(0,iK._)(this,eu,t),(0,iK._)(this,ec,e),(0,iK._)(this,ed,i),(0,iK._)(this,ew,a),(0,iK._)(this,ef,n),(0,iJ._)(this,ew).addEventListener("abort",()=>{var t,e;let i=new aX("Aborted");null===(t=(0,iJ._)(this,e_))||void 0===t||t.reject(i),null===(e=(0,iJ._)(this,ep))||void 0===e||e.reject(i),(0,iK._)(this,e_,void 0),(0,iK._)(this,ep,void 0)})}});async function lP(t,e){try{await aZ(t,e)}catch(t){ah(t instanceof aX)}}async function lR(t,e,i,a){let n=await fetch(e,{method:t,body:i,headers:a});if(!n.ok)throw Error("Got ".concat(n.status," fetching ").concat(e,": ").concat(await n.text()));return n}var lO=new Set,lA=Symbol(),lV=(eg=new WeakMap,eb=new WeakMap,ek=new WeakMap,eM=new WeakMap,eI=new WeakMap,eD=new WeakMap,class{hasIndexSubscription(t){for(let e of(0,iJ._)(this,eI))if(e.options.indexName===t)return!0;return!1}invoke(t,e,i){return(0,iJ._)(this,eg).call(this,t)}matches(t){for(let[e,i]of t)if(function(t,e,i,a){if(""===i){for(let e of a)if(t.has(e.key))return!0}for(let t of e)if(function(t,e,i){for(let a of i)if(function(t,e,i){let{indexName:a="",limit:n,prefix:s,startKey:r,startExclusive:l,startSecondaryKey:o}=t.options;if(e!==a)return!1;if(!a)return(void 0===n||!(n<=0))&&(!s&&!r||!(s&&(!i.startsWith(s)||lq(t,i))||r&&(l&&0>=nJ(i,r)||0>nJ(i,r)||lq(t,i))));if(!s&&!r&&!o)return!0;let[h,u]=sG(i);return!(s&&!h.startsWith(s)||o&&(l&&0>=nJ(h,o)||0>nJ(h,o))||r&&(l&&0>=nJ(u,r)||0>nJ(u,r)))}(t,e,a.key))return!0;return!1}(t,i,a))return!0;return!1}((0,iJ._)(this,eM),(0,iJ._)(this,eI),e,i))return!0;return!1}updateDeps(t,e){(0,iK._)(this,eM,t),(0,iK._)(this,eI,e)}onData(t){(0,iJ._)(this,ek)!==lA&&(0,iJ._)(this,eD).call(this,(0,iJ._)(this,ek),t)||((0,iK._)(this,ek,t),(0,iJ._)(this,eb).call(this,t))}constructor(t,e,i,a,n=ag){(0,iB._)(this,eg,{writable:!0,value:void 0}),(0,iB._)(this,eb,{writable:!0,value:void 0}),(0,iB._)(this,ek,{writable:!0,value:lA}),(0,iB._)(this,eM,{writable:!0,value:lO}),(0,iB._)(this,eI,{writable:!0,value:[]}),(0,iQ._)(this,"onError",void 0),(0,iQ._)(this,"onDone",void 0),(0,iB._)(this,eD,{writable:!0,value:void 0}),(0,iK._)(this,eg,t),(0,iK._)(this,eb,e),this.onError=i,this.onDone=a,(0,iK._)(this,eD,n)}}),lj=(eS=new WeakMap,eW=new WeakMap,eH=new WeakMap,ex=new WeakMap,class{hasIndexSubscription(t){return(0,iJ._)(this,eH)===t}onData(t){void 0!==t&&(0,iJ._)(this,eS).call(this,t)}invoke(t,e,i){let a=async(a,n,s,r)=>{let l;if(0===e){if(!(0,iJ._)(this,ex))return;ah(void 0===i);let e=[];for await(let i of t.scan({prefix:n,indexName:a}).entries())e.push({op:"add",key:i[0],newValue:i[1]});l=e}else{var o;ah(i),l=r(null!==(o=i.get(null!=a?a:""))&&void 0!==o?o:[])}let h=[],{length:u}=l;for(let t=lF(l,n,s);t<u&&s(l[t]).startsWith(n);t++)h.push(l[t]);return 0===e||h.length>0?h:void 0};return(0,iJ._)(this,eH)?a((0,iJ._)(this,eH),(0,iJ._)(this,eW),t=>t.key[0],t=>lU(t,sG)):a(void 0,(0,iJ._)(this,eW),t=>t.key,t=>lU(t,t=>t))}matches(t){var e;let i=t.get(null!==(e=(0,iJ._)(this,eH))&&void 0!==e?e:"");return void 0!==i&&function(t,e,i){if(""===e)return!0;let a=i?t=>sG(t.key)[0]:t=>t.key,n=lF(t,e,a);return n<t.length&&a(t[n]).startsWith(e)}(i,(0,iJ._)(this,eW),(0,iJ._)(this,eH))}updateDeps(t,e){}constructor(t,e){var i,a;(0,iB._)(this,eS,{writable:!0,value:void 0}),(0,iB._)(this,eW,{writable:!0,value:void 0}),(0,iB._)(this,eH,{writable:!0,value:void 0}),(0,iB._)(this,ex,{writable:!0,value:void 0}),(0,iQ._)(this,"onError",void 0),(0,iQ._)(this,"onDone",void 0),(0,iK._)(this,eS,t),(0,iK._)(this,eW,null!==(i=e.prefix)&&void 0!==i?i:""),(0,iK._)(this,eH,e.indexName),(0,iK._)(this,ex,null!==(a=e.initialValuesInFirstDiff)&&void 0!==a&&a)}});function lU(t,e){return t.map(t=>{let i=e(t.key);switch(t.op){case"add":return{op:"add",key:i,newValue:t.newValue};case"change":return{op:"change",key:i,oldValue:t.oldValue,newValue:t.newValue};case"del":return{op:"del",key:i,oldValue:t.oldValue}}})}var lL=(eC=new WeakMap,eE=new WeakMap,eN=new WeakMap,eP=new WeakMap,eR=new WeakSet,eO=new WeakSet,eA=new WeakSet,class{addSubscription(t,e){let{onData:i,onError:a,onDone:n,isEqual:s}=e,r=new lV(t,i,a,n,s);return(0,i$._)(this,eR,op).call(this,r)}addWatch(t,e){let i=new lj(t,null!=e?e:{});return(0,i$._)(this,eR,op).call(this,i)}clear(){var t;for(let e of(0,iJ._)(this,eC))null===(t=e.onDone)||void 0===t||t.call(e);(0,iJ._)(this,eC).clear()}async fire(t){let e=function*(t,e){for(let i of t)i.matches(e)&&(yield i)}((0,iJ._)(this,eC),t);await (0,i$._)(this,eO,o_).call(this,e,1,t)}shouldComputeDiffs(){return(0,iJ._)(this,eC).size>0}shouldComputeDiffsForIndex(t){for(let e of(0,iJ._)(this,eC))if(e.hasIndexSubscription(t))return!0;return!1}constructor(t,e){(0,iX._)(this,eR),(0,iX._)(this,eO),(0,iX._)(this,eA),(0,iB._)(this,eC,{writable:!0,value:new Set}),(0,iB._)(this,eE,{writable:!0,value:new Set}),(0,iB._)(this,eN,{writable:!0,value:void 0}),(0,iB._)(this,eP,{writable:!0,value:void 0}),(0,iQ._)(this,"hasPendingSubscriptionRuns",!1),(0,iK._)(this,eN,t),(0,iK._)(this,eP,e)}});function lq(t,e){let{inclusiveLimitKey:i}=t;return void 0!==t.options.limit&&void 0!==i&&nJ(e,i)>0}function lF(t,e,i){return nX(t.length,a=>nJ(e,i(t[a])))}var lT="",lz=new Map;function lG(t){let e=lz.get(t);return e?(e++,lz.set(t,e)):(lz.set(t,0),e=0),"".concat(t,"-").concat(function(){if(""===lT){let t=new Uint8Array(4);crypto.getRandomValues(t),lT=Array.from(t,t=>t.toString(16)).join("")}return lT}(),"-").concat(e)}var lJ=()=>{},lB={type:"NewClientGroup"},lK=(eV=new WeakMap,ej=new WeakMap,eU=new WeakMap,eL=new WeakMap,eq=new WeakMap,eF=new WeakMap,eT=new WeakMap,ez=new WeakMap,eG=new WeakMap,eJ=new WeakMap,eB=new WeakMap,eK=new WeakMap,eY=new WeakMap,e$=new WeakMap,eX=new WeakMap,eQ=new WeakMap,eZ=new WeakMap,e0=new WeakMap,e1=new WeakMap,e2=new WeakMap,e4=new WeakMap,e5=new WeakMap,e3=new WeakMap,e7=new WeakMap,e6=new WeakMap,e8=new WeakMap,e9=new WeakMap,it=new WeakMap,ie=new WeakMap,ii=new WeakMap,ia=new WeakMap,is=new WeakMap,ir=new WeakMap,il=new WeakMap,io=new WeakMap,ih=new WeakMap,iu=new WeakSet,ic=new WeakMap,id=new WeakSet,iw=new WeakSet,ip=new WeakSet,i_=new WeakSet,iv=new WeakSet,im=new WeakSet,iy=new WeakSet,ig=new WeakSet,ib=new WeakSet,ik=new WeakSet,iM=new WeakSet,iI=new WeakSet,iD=new WeakSet,iS=new WeakSet,iW=new WeakSet,iH=new WeakSet,ix=new WeakSet,iC=new WeakSet,iE=new WeakSet,iN=new WeakSet,iP=new WeakSet,iR=new WeakSet,iO=new WeakSet,iA=new WeakSet,iV=new WeakSet,ij=new WeakMap,iU=new WeakSet,iL=new WeakSet,iq=new WeakSet,iF=new WeakSet,iT=new WeakSet,class{get idbName(){var t,e;let i;return t=this.name,e=this.schemaVersion,i="rep:".concat(t,":").concat(7),e?"".concat(i,":").concat(e):i}get requestOptions(){return(0,iJ._)(this,e5)}get profileID(){return(0,iJ._)(this,eK)}get clientID(){return(0,iJ._)(this,eG)}get clientGroupID(){return(0,iJ._)(this,eY)}get online(){return(0,iJ._)(this,ez)}get closed(){return(0,iJ._)(this,eT)}async close(){var t;(0,iK._)(this,eT,!0);let{promise:e,resolve:i}=(0,i0.U)();lY.set(this.name,e),(0,iJ._)(this,it).abort(),null===(t=rE())||void 0===t||t.removeEventListener("visibilitychange",(0,iJ._)(this,ic)),await (0,iJ._)(this,eB);let a=[(0,iJ._)(this,e7).close(),(0,iJ._)(this,e6).close(),(0,iJ._)(this,e8).close()];(0,iJ._)(this,e2).close(),(0,iJ._)(this,e4).close(),(0,iJ._)(this,eV).clear(),(0,iJ._)(this,eQ)&&clearTimeout((0,iJ._)(this,eQ)),await Promise.all(a),lY.delete(this.name),i()}push(){let{now:t=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return lQ((0,iJ._)(this,e4).send(t))}pull(){let{now:t=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return lQ((0,iJ._)(this,e2).send(t))}async poke(t){await (0,iJ._)(this,eB);let{clientID:e}=this,i=lG(e),a=(0,iJ._)(this,e9).withContext("handlePullResponse").withContext("requestID",i),{pullResponse:n}=t;if(aH(n)){(0,i$._)(this,iD,oN).call(this,n);return}if(aW(n)){await (0,i$._)(this,iE,oj).call(this);return}let s=await ls(a,(0,iJ._)(this,e7),t.baseCookie,n,e,7);switch(s.type){case 0:await (0,i$._)(this,im,oD).call(this,s.syncHead,i);break;case 2:throw Error("unexpected base cookie for poke: "+JSON.stringify(t))}}subscribe(t,e){return"function"==typeof e&&(e={onData:e}),(0,iJ._)(this,eV).addSubscription(t,e)}experimentalWatch(t,e){return(0,iJ._)(this,eV).addWatch(t,e)}query(t){return(0,iJ._)(this,ij).call(this,t)}experimentalPendingMutations(){return nH((0,iJ._)(this,e7),lk)}constructor(t){var e,i,a,n,s,r,l,o,h;(0,iB._)(this,eF,{get:om,set:void 0}),(0,iX._)(this,iu),(0,iX._)(this,id),(0,iX._)(this,iw),(0,iX._)(this,ip),(0,iX._)(this,i_),(0,iX._)(this,iv),(0,iX._)(this,im),(0,iX._)(this,iy),(0,iX._)(this,ig),(0,iX._)(this,ib),(0,iX._)(this,ik),(0,iX._)(this,iM),(0,iX._)(this,iI),(0,iX._)(this,iD),(0,iX._)(this,iS),(0,iX._)(this,iW),(0,iX._)(this,iH),(0,iX._)(this,ix),(0,iX._)(this,iC),(0,iX._)(this,iE),(0,iX._)(this,iN),(0,iX._)(this,iP),(0,iX._)(this,iR),(0,iX._)(this,iO),(0,iX._)(this,iA),(0,iX._)(this,iV),(0,iX._)(this,iU),(0,iX._)(this,iL),(0,iX._)(this,iq),(0,iX._)(this,iF),(0,iX._)(this,iT),(0,iQ._)(this,"pullURL",void 0),(0,iQ._)(this,"pushURL",void 0),(0,iQ._)(this,"auth",void 0),(0,iQ._)(this,"name",void 0),(0,iB._)(this,eV,{writable:!0,value:void 0}),(0,iB._)(this,ej,{writable:!0,value:void 0}),(0,iB._)(this,eU,{writable:!0,value:!1}),(0,iB._)(this,eL,{writable:!0,value:void 0}),(0,iB._)(this,eq,{writable:!0,value:0}),(0,iQ._)(this,"schemaVersion",void 0),(0,iB._)(this,eT,{writable:!0,value:!1}),(0,iB._)(this,ez,{writable:!0,value:!0}),(0,iB._)(this,eG,{writable:!0,value:na()}),(0,iB._)(this,eJ,{writable:!0,value:void 0}),(0,iB._)(this,eB,{writable:!0,value:void 0}),(0,iB._)(this,eK,{writable:!0,value:void 0}),(0,iB._)(this,eY,{writable:!0,value:void 0}),(0,iB._)(this,e$,{writable:!0,value:void 0}),(0,iB._)(this,eX,{writable:!0,value:void 0}),(0,iB._)(this,eQ,{writable:!0,value:null}),(0,iB._)(this,eZ,{writable:!0,value:{}}),(0,iQ._)(this,"mutate",void 0),(0,iB._)(this,e0,{writable:!0,value:0}),(0,iB._)(this,e1,{writable:!0,value:0}),(0,iB._)(this,e2,{writable:!0,value:void 0}),(0,iB._)(this,e4,{writable:!0,value:void 0}),(0,iQ._)(this,"pullInterval",void 0),(0,iQ._)(this,"pushDelay",void 0),(0,iB._)(this,e5,{writable:!0,value:void 0}),(0,iQ._)(this,"puller",void 0),(0,iQ._)(this,"pusher",void 0),(0,iB._)(this,e3,{writable:!0,value:void 0}),(0,iB._)(this,e7,{writable:!0,value:void 0}),(0,iB._)(this,e6,{writable:!0,value:void 0}),(0,iB._)(this,e8,{writable:!0,value:void 0}),(0,iB._)(this,e9,{writable:!0,value:void 0}),(0,iB._)(this,it,{writable:!0,value:new AbortController}),(0,iB._)(this,ie,{writable:!0,value:!1}),(0,iB._)(this,ii,{writable:!0,value:void 0}),(0,iB._)(this,ia,{writable:!0,value:void 0}),(0,iB._)(this,is,{writable:!0,value:void 0}),(0,iB._)(this,ir,{writable:!0,value:new lN(()=>(0,i$._)(this,iW,oR).call(this),1e3,500,(0,iJ._)(this,it).signal)}),(0,iB._)(this,il,{writable:!0,value:void 0}),(0,iB._)(this,io,{writable:!0,value:new lN(()=>(0,i$._)(this,iH,oO).call(this),1e3,500,(0,iJ._)(this,it).signal)}),(0,iB._)(this,ih,{writable:!0,value:void 0}),(0,iQ._)(this,"onSync",null),(0,iQ._)(this,"onClientStateNotFound",l$),(0,iQ._)(this,"onUpdateNeeded",l$),(0,iQ._)(this,"getAuth",null),(0,iB._)(this,ic,{writable:!0,value:async()=>{var t;(0,iJ._)(this,eT)||(null===(t=rE())||void 0===t?void 0:t.visibilityState)==="visible"&&await (0,i$._)(this,id,og).call(this)}}),(0,iQ._)(this,"onOnlineChange",null),(0,iB._)(this,ij,{writable:!0,value:async t=>{await (0,iJ._)(this,eB);let{clientID:e}=this;return nH((0,iJ._)(this,e7),async i=>{try{let a=await sB(sc,i,7),n=new rX(e,a,(0,iJ._)(this,e9));return await t(n)}catch(t){throw await (0,i$._)(this,iF,oK).call(this,t)}})}});let{name:u,logLevel:c="info",logSinks:d=[iZ.hO],pullURL:w="",auth:f,pushDelay:p=10,pushURL:_="",schemaVersion:v="",pullInterval:m=6e4,mutators:y={},requestOptions:g={},puller:b,pusher:k,licenseKey:M,experimentalCreateKVStore:I,indexes:D={}}=t;if(this.auth=null!=f?f:"",this.pullURL=w,this.pushURL=_,"string"!=typeof u||!u)throw TypeError("name is required and must be non-empty");this.name=u,this.schemaVersion=v,this.pullInterval=m,this.pushDelay=p,this.puller=null!=b?b:function(t){async function e(e,i){let[a,n]=await ak(t.pullURL,t.auth,i,e);return a?{response:await a.json(),httpRequestInfo:n}:{httpRequestInfo:n}}return aE.add(e),e}(this),this.pusher=null!=k?k:function(t){async function e(e,i){let[a,n]=await ak(t.pushURL,t.auth,i,e);if(!a)return{httpRequestInfo:n};let s={httpRequestInfo:n},r;try{r=await a.json()}catch(t){return s}return(aW(r)||aH(r))&&(s.response=r),s}return r7.add(e),e}(this);let S=null===(a=t.enableMutationRecovery)||void 0===a||a;(0,iK._)(this,ih,null===(n=t.enableLicensing)||void 0===n||n),(0,iK._)(this,ii,null===(s=t.enableScheduledPersist)||void 0===s||s),(0,iK._)(this,ia,null===(r=t.enableScheduledRefresh)||void 0===r||r),(0,iK._)(this,is,null===(l=t.enablePullAndPushInOpen)||void 0===l||l),t.exposeInternalAPI&&t.exposeInternalAPI({persist:()=>(0,i$._)(this,iW,oR).call(this),refresh:()=>(0,i$._)(this,iH,oO).call(this),lastMutationID:()=>(0,iJ._)(this,eq)});let W=1===d.length?d[0]:new iZ.Pz(d);(0,iK._)(this,e9,new iZ.O$(c,{name:u},W)),null===(e=(i=(0,iJ._)(this,e9)).debug)||void 0===e||e.call(i,"Constructing Replicache",{name:u,"replicache version":"14.2.2"}),(0,iK._)(this,eV,new lL((0,iJ._)(this,ij),(0,iJ._)(this,e9)));let H=t=>{var e;return e=(0,iJ._)(this,e9),nW()?new nS(e,t):new aL(t)},x;x=I?(H=I)(this.idbName):H(this.idbName),(0,iK._)(this,eL,H),(0,iK._)(this,e8,new ry(H)),(0,iK._)(this,e6,new nk(x,nl,no)),(0,iK._)(this,e7,new rj((0,iJ._)(this,e6),104857600,nl,no));let C=(0,i0.U)();(0,iK._)(this,eB,C.promise),(0,iK._)(this,e3,M);let E=(0,i0.U)();(0,iK._)(this,e$,E.promise);let N=(0,i0.U)();(0,iK._)(this,eX,N.promise);let{minDelayMs:P=30,maxDelayMs:R=6e4}=g;(0,iK._)(this,e5,{maxDelayMs:R,minDelayMs:P});let O=(o=rE(),h=(0,iJ._)(this,it).signal,o?new rW(o,0,h):new rC);(0,iK._)(this,e2,new rO((0,iJ._)(this,e9).withContext("PULL"),new rP(this,()=>(0,i$._)(this,iy,oS).call(this)),O)),(0,iK._)(this,e4,new rO((0,iJ._)(this,e9).withContext("PUSH"),new rR(this,()=>(0,i$._)(this,iI,oE).call(this)))),this.mutate=(0,i$._)(this,iL,oJ).call(this,y);let A=(0,i0.U)();(0,iK._)(this,eK,A.promise);let V=(0,i0.U)();(0,iK._)(this,eY,V.promise),(0,iK._)(this,ej,new ld({delegate:this,lc:(0,iJ._)(this,e9),enableMutationRecovery:S,wrapInOnlineCheck:(0,i$._)(this,ib,oH).bind(this),wrapInReauthRetries:(0,i$._)(this,ik,ox).bind(this),isPullDisabled:(0,i$._)(this,ig,oW).bind(this),isPushDisabled:(0,i$._)(this,iM,oC).bind(this),clientGroupIDPromise:(0,iJ._)(this,eY)})),(0,iK._)(this,il,function(t,e,i){if(e.aborted)return()=>{};let a=new lb("replicache-on-persist:".concat(t));return a.onmessage=t=>{let{data:e}=t;aw(e),au(e.clientGroupID),au(e.clientID),i({clientGroupID:e.clientGroupID,clientID:e.clientID})},e.addEventListener("abort",()=>{a.close()}),t=>{e.aborted||(a.postMessage(t),i(t))}}(this.name,(0,iJ._)(this,it).signal,t=>{(0,i$._)(this,iR,oq).call(this,t)})),(0,i$._)(this,iu,oy).call(this,D,A.resolve,V.resolve,C.resolve,E.resolve,N.resolve)}}),lY=new Map;function l$(){"u">typeof location&&location.reload()}var lX=class extends Error{};async function lQ(t){let e=await t;if(e)throw e.error}async function lZ(t){let e=async t=>{let{promise:e,resolve:i,reject:a}=(0,i0.U)(),n=indexedDB.open(t);n.onupgradeneeded=()=>{let e=n.transaction;(function(t){if(null===t)throw Error("Expected non-null value")})(e),e.abort(),(0,iK._)(this,d,!0),a(new aJ("Replicache IndexedDB not found: ".concat(t)))},n.onsuccess=()=>i(n.result),n.onerror=()=>a(n.error);let s=await e;return s.onversionchange=()=>s.close(),s},i=await (0,iJ._)(this,u);try{return t(i)}catch(a){if(!(0,iJ._)(this,c)&&a instanceof DOMException){if("InvalidStateError"===a.name)return(0,iK._)(this,u,e(i.name)),t(await (0,iJ._)(this,u));if("NotFoundError"===a.name)throw(0,iK._)(this,d,!0),indexedDB.deleteDatabase(i.name),new aJ("Replicache IndexedDB ".concat(i.name," missing object store. Deleting db."))}throw a}}async function l0(t,e){await (0,i$._)(this,O,l2).call(this,t),(0,i$._)(this,A,l4).call(this,t,e)&&await (0,i$._)(this,R,l1).call(this,t,e)}async function l1(t,e){if(t===nr)return;let i=await (0,iJ._)(this,H).getRefs(t);if(void 0!==i){var a;null===(a=(0,iJ._)(this,x))||void 0===a||a.add(t);let n=i.map(t=>(0,i$._)(this,P,l0).call(this,t,e));await Promise.all(n)}}function l2(t){let e=(0,iJ._)(this,E).get(t);return void 0===e&&(e=(async()=>{let e=await (0,iJ._)(this,H).getRefCount(t)||0;return(0,iJ._)(this,C).set(t,e),e})(),(0,iJ._)(this,E).set(t,e)),e}function l4(t,e){let i=(0,iJ._)(this,C).get(t);return ac(i),(0,iJ._)(this,C).set(t,i+e),0===i&&1===e||1===i&&-1===e}async function l5(t,e){let i=await this.getHead(t),a=nm(t),n;n=void 0===e?this.e.del(a):this.e.put(a,e);let s=(0,iJ._)(this,F).get(t);void 0===s?(0,iJ._)(this,F).set(t,{new:e,old:i}):s.new=e,await n}async function l3(t){let e=[];for(let[i,a]of t)if(0===a)e.push((0,i$._)(this,G,l7).call(this,i));else{let t=nv(i);e.push(this.e.put(t,a))}await Promise.all(e)}async function l7(t){await Promise.all([this.e.del(np(t)),this.e.del(n_(t)),this.e.del(nv(t))]),(0,iJ._)(this,q).delete(t)}async function l6(t){try{return await t((0,iJ._)(this,K))}catch(a){var e,i;if(nW()&&a instanceof DOMException&&"InvalidStateError"===a.name&&"A mutation operation was attempted on a database that did not allow mutations."===a.message)return(0,iJ._)(this,K) instanceof aL&&(null===(e=(i=(0,iJ._)(this,J)).info)||void 0===e||e.call(i,"Switching to MemStore because of Firefox private browsing error"),(0,iK._)(this,K,new a$((0,iJ._)(this,B)))),t((0,iJ._)(this,K));throw a}}function l8(t,e,i){for(var a=arguments.length,n=Array(a>3?a-3:0),s=3;s<a;s++)n[s-3]=arguments[s];if(this.isMutable)return this.entries.splice(e,i,...n),this.c(t),this;let r=n6(this.entries,e,i,...n);return t.newDataNodeImpl(r)}async function l9(t,e,i){let a=this.level-1,n=this.entries,s,r,l;if(e>0){let a=n[e-1][1];s=nQ((await t.getNode(a)).entries,i.entries),r=e-1,l=2}else if(e<n.length-1){let a=n[e+1][1],o=await t.getNode(a);s=nQ(i.entries,o.entries),r=e,l=2}else s=i.entries,r=e,l=1;let o=se(s,t=>t[2],t.minSize-t.chunkHeaderSize,t.maxSize-t.chunkHeaderSize),h=[];for(let e of o){let i=sn(t.newNodeImpl(e,a),t.getEntrySize);h.push(i)}if(this.isMutable)return this.entries.splice(r,l,...h),this.c(t),this;let u=n6(n,r,l,...h);return t.newInternalNodeImpl(u,this.level)}function ot(t,e,i){if(this.isMutable)return this.entries.splice(e,1,i),this.c(t),this;let a=n6(this.entries,e,1,i);return t.newInternalNodeImpl(a,this.level)}function oe(t){ah(t.isMutable),(0,iJ._)(this,te).set(t.hash,t),this.p.set(t.hash,t)}async function oi(t){let e,i=new sY;if(!t.shouldComputeDiffs())return i;let a=[];if((0,iJ._)(this,ts)){let t=new sl((0,iJ._)(this,tn),(0,iJ._)(this,to),(0,iJ._)(this,ts).valueHash);a=await sV(t,this.map)}for(let[n,s]of(i.set("",a),e=(0,iJ._)(this,ts)?sK((0,iJ._)(this,ts),(0,iJ._)(this,tn),(0,iJ._)(this,to)):new Map,this.indexes)){if(!t.shouldComputeDiffsForIndex(n))continue;let a=e.get(n);ah(s!==a);let r=await (a?sV(a.map,s.map):su(s.map,"add"));i.set(n,r)}for(let[a,n]of e)if(!this.indexes.has(a)&&t.shouldComputeDiffsForIndex(a)){let t=await su(n.map,"del");i.set(a,t)}return i}function oa(t){return nC((0,iJ._)(this,tu),async e=>{let i={...await rg(e),[t.name]:t};return await e.put("dbs",i),i})}function on(t){if(t!==this.visibilityState)for(let e of(this.visibilityState=t,(0,iJ._)(this,tp))){let{resolve:i,state:a}=e;a===t&&(i(),(0,iJ._)(this,tp).delete(e))}}function os(t){if(this.visibilityState===t)return Promise.resolve();let{promise:e,resolve:i}=(0,i0.U)();return(0,iJ._)(this,tp).add({resolve:i,state:t}),e}function or(){if((0,iJ._)(this,tW)){let t=(0,iJ._)(this,tW);(0,iK._)(this,tW,void 0),t()}}function ol(){let{promise:t,resolve:e}=(0,i0.U)();return(0,iK._)(this,tW,e),t}async function oo(t,e){let i=await this.getHead(t),a=this.i.get(t);void 0===a?this.i.set(t,{new:e,old:i}):a.new=e}function oh(){if(!(0,iJ._)(this,tK))for(let t of this.cacheEntries.values()){if((0,iJ._)(this,tB)<=(0,iJ._)(this,tT))break;(0,i$._)(this,tQ,oc).call(this,t)}}function ou(t,e){let i=null!=e?e:(0,iJ._)(this,tz).call(this,t);return!(i>(0,iJ._)(this,tT))&&((0,iK._)(this,tB,(0,iJ._)(this,tB)+i),this.cacheEntries.set(t.hash,{chunk:t,size:i}),!0)}function oc(t){let{hash:e}=t.chunk;(0,iK._)(this,tB,(0,iJ._)(this,tB)-t.size),this.cacheEntries.delete(e)}function od(t){(0,iJ._)(this,tG).delete(t),(0,iJ._)(this,tJ).delete(t);let e=this.cacheEntries.get(t);e&&((0,iK._)(this,tB,(0,iJ._)(this,tB)-e.size),this.cacheEntries.delete(t))}function ow(t){return rY(t,(0,iJ._)(this,t0),(0,iJ._)(this,t1),(0,iJ._)(this,t2),(0,iJ._)(this,t4))}async function of(){try{await (0,iJ._)(this,ev)}catch(t){}if(await (0,iJ._)(this,em),(0,iJ._)(this,ep)&&(await (0,iJ._)(this,ef).call(this,(0,iJ._)(this,ec)),(0,iJ._)(this,ep))){var t,e;(0,iK._)(this,em,lP((0,iJ._)(this,ed),(0,iJ._)(this,ew))),(0,iK._)(this,e_,(0,iJ._)(this,ep)),(0,iK._)(this,ep,void 0);try{(0,iK._)(this,ev,(0,iJ._)(this,eu).call(this)),await (0,iJ._)(this,ev),null===(t=(0,iJ._)(this,e_))||void 0===t||t.resolve()}catch(t){null===(e=(0,iJ._)(this,e_))||void 0===e||e.reject(t)}(0,iK._)(this,e_,void 0)}}function op(t){return(0,iJ._)(this,eC).add(t),(0,i$._)(this,eA,ov).call(this,t),()=>(0,iJ._)(this,eC).delete(t)}async function o_(t,e,i){let a=[...t];if(0===a.length)return;let n=await (0,iJ._)(this,eN).call(this,t=>Promise.allSettled(a.map(async a=>{let n=new r0(t);try{return await a.invoke(n,e,i)}finally{a.updateDeps(n.keys,n.scans)}})));for(let t=0;t<a.length;t++){var s,r;let e=a[t],i=n[t];"fulfilled"===i.status?e.onData(i.value):e.onError?e.onError(i.reason):null===(s=(r=(0,iJ._)(this,eP)).error)||void 0===s||s.call(r,"Error in subscription body:",i.reason)}}async function ov(t){if((0,iJ._)(this,eE).add(t),!this.hasPendingSubscriptionRuns){this.hasPendingSubscriptionRuns=!0,await Promise.resolve(),this.hasPendingSubscriptionRuns=!1;let t=[...(0,iJ._)(this,eE)];(0,iJ._)(this,eE).clear(),await (0,i$._)(this,eO,o_).call(this,t,0,void 0)}}function om(){return{name:this.idbName,replicacheName:this.name,replicacheFormatVersion:7,schemaVersion:this.schemaVersion}}async function oy(t,e,i,a,n,s){var r,l,o,h,u,c,d,w,f,p;let _;let{clientID:v}=this;await lY.get(this.name),await (0,iJ._)(this,e8).getProfileID().then(e),await (0,iJ._)(this,e8).putDatabase((0,iJ._)(this,eF));let[m,y,g,b]=await (l=(0,iJ._)(this,e9),o=(0,iJ._)(this,e6),h=Object.keys((0,iJ._)(this,eZ)),nx(o,async e=>{async function i(i,n,s,r){let l=sN(i,{},n,s,r),o=e.createChunk(l,sR(l)),u=na(),c={heartbeatTimestampMs:Date.now(),refreshHashes:[o.hash],persistHash:null,clientGroupID:u},d=new Map(a).set(v,c),w={headHash:o.hash,mutatorNames:h,indexes:t,mutationIDs:{},lastServerAckdMutationIDs:{},disabled:!1};return await Promise.all([e.putChunk(o),rv(d,e),nU(u,w,e)]),await e.commit(),[c,o.hash,d,!0]}let a=await rr(e),n=await rw(e,h,t);if(2===n.type){let{clientGroupID:t,headHash:i}=n,s={clientGroupID:t,refreshHashes:[i],heartbeatTimestampMs:Date.now(),persistHash:null},r=new Map(a).set(v,s);return await rv(r,e),await e.commit(),[s,i,r,!1]}if(0===n.type){let a=e.createChunk(si,[]);await e.putChunk(a);let n=[];for(let[e,i]of Object.entries(t)){let t=function(t,e){var i,a;return{name:t,keyPrefix:null!==(i=e.prefix)&&void 0!==i?i:"",jsonPointer:e.jsonPointer,allowEmpty:null!==(a=e.allowEmpty)&&void 0!==a&&a}}(e,i);n.push({definition:t,valueHash:a.hash})}return i(null,null,a.hash,n)}ah(1===n.type);let{snapshot:s}=n,r=[],{valueHash:o,indexes:u}=s,c=new sl(e,7,o);for(let[i,a]of Object.entries(t)){let{prefix:t="",jsonPointer:n,allowEmpty:s=!1}=a,o={name:i,keyPrefix:t,jsonPointer:n,allowEmpty:s},h=function(t,e){return t.find(t=>{var i,a,n;return(i=t.definition).jsonPointer===e.jsonPointer&&(null!==(a=i.allowEmpty)&&void 0!==a&&a)===(null!==(n=e.allowEmpty)&&void 0!==n&&n)&&i.keyPrefix===e.keyPrefix})}(u,o);if(h)r.push({definition:o,valueHash:h.valueHash});else{let i=await s5(l,e,c,t,n,s,7);r.push({definition:o,valueHash:await i.flush()})}}return i(s.meta.basisHash,s.meta.cookieJSON,s.valueHash,r)}));i(m.clientGroupID),await nC((0,iJ._)(this,e7),t=>t.setHead(sc,y)),(0,iK._)(this,eJ,await nH((0,iJ._)(this,e7),async t=>{let e=await t.getHead(sc);if(void 0===e)throw Error("No head found for ".concat(sc));return e})),a(),await (0,i$._)(this,iw,ob).call(this,n),(0,iJ._)(this,is)&&(this.pull().catch(lJ),this.push().catch(lJ));let{signal:k}=(0,iJ._)(this,it);u=(0,iJ._)(this,e6),c=()=>{(0,i$._)(this,iC,oV).call(this,v)},a0("Heartbeat",async()=>{iG=nC(u,async t=>{let e=await rr(t),i=e.get(v);if(!i)throw new ro(v);let a={...i,heartbeatTimestampMs:Date.now()},n=new Map(e).set(v,a);return await rv(n,t),n});try{return await iG}catch(t){if(t instanceof ro){c();return}throw t}},()=>6e4,(0,iJ._)(this,e9),k),d=(0,iJ._)(this,e6),a0("ClientGC",()=>nC(d,async t=>{let e=Date.now(),i=await rr(t),a=Array.from(i).filter(t=>{let[i,a]=t;return i===v||e-a.heartbeatTimestampMs<=6048e5});if(a.length===i.size)return i;let n=new Map(a);return await rv(n,t),n}),()=>3e5,(0,iJ._)(this,e9),k),w=(0,iJ._)(this,e8),f=(0,iJ._)(this,e9),_=!0,a0("CollectIDBDatabases",async()=>{await rb(w,Date.now(),2592e6,12096e5)},()=>_?(_=!1,3e5):432e5,f,k),p=(0,iJ._)(this,e6),a0("ClientGroupGC",()=>nC(p,async t=>{let e=await rr(t),i=new Set;for(let t of e.values())rs(t),i.add(t.clientGroupID);let a=new Map;for(let[e,n]of(await nV(t)))(i.has(e)||nz(n))&&a.set(e,n);return await nj(a,t),a}),()=>3e5,(0,iJ._)(this,e9),k),function(t,e,i,a,n,s,r){if(i.aborted)return;let l=new lb("replicache-new-client-group-v1:".concat(t));if(n){l.postMessage({clientGroupID:a,idbName:e});let i=new lb("replicache-new-client-group:".concat(t));i.postMessage([a]),i.close()}l.onmessage=async t=>{let{data:i}=t;if("object"==typeof i&&"string"==typeof i.clientGroupID&&"string"==typeof i.idbName){let{clientGroupID:t,idbName:n}=i;if(t!==a){if(n===e)await nH(r,async e=>await nT(t,e)!==void 0)&&s();else{s();return}}}},i.addEventListener("abort",()=>l.close())}(this.name,this.idbName,k,m.clientGroupID,b,()=>{(0,i$._)(this,iN,oU).call(this,lB)},(0,iJ._)(this,e6)),function(t,e,i){let a=setInterval(t,3e5);i.addEventListener("abort",()=>{clearInterval(a)})}(()=>(0,i$._)(this,iT,oY).call(this),0,k),(0,i$._)(this,iT,oY).call(this,g),null===(r=rE())||void 0===r||r.addEventListener("visibilitychange",(0,iJ._)(this,ic)),await (0,i$._)(this,i_,oM).call(this,s,(0,iJ._)(this,e9),k)}async function og(){let{clientID:t}=this,e=await nH((0,iJ._)(this,e6),e=>ru(t,e));return e||(0,i$._)(this,iC,oV).call(this,t),!e}async function ob(t){var e,i,a,n,s,r,l,o,h,u;if(!(0,iJ._)(this,ih)){t(!0);return}if(!(0,iJ._)(this,e3)){await (0,i$._)(this,ip,ok).call(this,(0,iJ._)(this,e9),"license key ReplicacheOptions.licenseKey is not set",!0,t);return}if(null===(e=(i=(0,iJ._)(this,e9)).debug)||void 0===e||e.call(i,"Replicache license key: ".concat((0,iJ._)(this,e3))),(0,iJ._)(this,e3)===al){null===(a=(n=(0,iJ._)(this,e9)).info)||void 0===a||a.call(n,"Skipping license check for TEST_LICENSE_KEY. You may ONLY use this key for automated (e.g., unit/CI) testing. See https://replicache.dev for more information."),t(!0),(0,iK._)(this,eQ,setTimeout(async()=>{await (0,i$._)(this,ip,ok).call(this,(0,iJ._)(this,e9),"Test key expired",!0,t)},3e5));return}try{let e=await ar(lR,ao,(0,iJ._)(this,e3),(0,iJ._)(this,e9));if(e.pleaseUpdate&&(null===(s=(r=(0,iJ._)(this,e9)).error)||void 0===s||s.call(r,"You are using an old version of Replicache that uses deprecated licensing features. Please update Replicache else it may stop working.")),"VALID"===e.status)null===(l=(o=(0,iJ._)(this,e9)).debug)||void 0===l||l.call(o,"License is valid.");else{await (0,i$._)(this,ip,ok).call(this,(0,iJ._)(this,e9),"status: ".concat(e.status),e.disable,t);return}}catch(t){null===(h=(u=(0,iJ._)(this,e9)).error)||void 0===h||h.call(u,"Error checking license: ".concat(t))}t(!0)}async function ok(t,e,i,a){var n,s;null===(n=t.error)||void 0===n||n.call(t,"** REPLICACHE LICENSE NOT VALID ** Replicache license key '".concat((0,iJ._)(this,e3),"' is not valid (").concat(e,"). Please run 'npx replicache get-license' to get a license key or contact hello@replicache.dev for help.")),i&&(await this.close(),null===(s=t.error)||void 0===s||s.call(t,"** REPLICACHE DISABLED **")),a(!1)}async function oM(t,e,i){if(!(0,iJ._)(this,ih)||!(0,iJ._)(this,e3)||(0,iJ._)(this,e3)===al){t(!1);return}let a=async()=>{try{await as(lR,ao,(0,iJ._)(this,e3),await this.profileID,e)}catch(e){var t,i;null===(t=(i=(0,iJ._)(this,e9)).info)||void 0===t||t.call(i,"Error sending license active ping: ".concat(e))}};await a(),t(!0),a0("LicenseActive",a,()=>864e5,e,i)}async function oI(t,e){let i=(0,iJ._)(this,eJ);a_(i),t!==i&&((0,iK._)(this,eJ,t),await (0,iJ._)(this,eV).fire(e))}async function oD(t,e){for(;;){if((0,iJ._)(this,eT))return;await (0,iJ._)(this,eB);let{clientID:i}=this,a=(0,iJ._)(this,e9).withContext("maybeEndPull").withContext("requestID",e),{replayMutations:n,diffs:s}=await function(t,e,i,a,n,s){return nx(t,async t=>{var r;let l=await t.getHead(lt);if(void 0===l)throw Error("Missing sync head");if(l!==i)throw null===(r=e.error)||void 0===r||r.call(e,"maybeEndPull, Wrong sync head. Expecting:",i,"got:",l),Error("Wrong sync head");let o=await sb(l,t),h=await t.getHead(sc);if(void 0===h)throw Error("Missing main head");let u=await sb(h,t),{meta:c}=o,d=c.basisHash;if(null===o)throw Error("Sync snapshot with no basis");if(d!==u.chunk.hash)throw Error("Overlapping syncs");let w=await sS(l,t),f=[];for(let e of(await s_(h,t))){let i=a;sd(e)&&(i=e.meta.clientID),await e.getMutationID(i,t)>await w.getMutationID(i,t)&&f.push(e)}f.reverse();let p=new sY;if(f.length>0)return{syncHead:l,replayMutations:f,diffs:p};let _=await sS(h,t);if(n.shouldComputeDiffs()){let e=new sl(t,s,_.valueHash),i=new sl(t,s,w.valueHash),a=await sV(e,i);p.set("",a),await sX(_,w,t,p,n,s)}if(await Promise.all([t.setHead(sc,l),t.removeHead(lt)]),await t.commit(),e.debug){let[t,i]=sM(u,a),[n,s]=sM(o,a);e.debug("Successfully pulled new snapshot with lastMutationID:",n,"(prev:",t,"), cookie: ",s,"(prev:",i,"), sync head hash:",l,", main head hash:",h,", valueHash:",w.valueHash,"(prev:",u.valueHash)}return{syncHead:l,replayMutations:[],diffs:p}})}((0,iJ._)(this,e7),a,t,i,(0,iJ._)(this,eV),7);if(!n||0===n.length){await (0,i$._)(this,iv,oI).call(this,t,s),(0,i$._)(this,iP,oL).call(this);return}for(let e of n){(0,iJ._)(this,eV).hasPendingSubscriptionRuns&&await Promise.resolve();let{meta:n}=e;t=await nx((0,iJ._)(this,e7),s=>r3(e,s,t,lt,(0,iJ._)(this,eZ),a,sH(n)?n.clientID:i,7))}}}function oS(){return(0,i$._)(this,ig,oW).call(this)?Promise.resolve(!0):(0,i$._)(this,ib,oH).call(this,async()=>{try{(0,i$._)(this,iV,oz).call(this,0,1);let{syncHead:t,requestID:e,ok:i}=await (0,i$._)(this,iS,oP).call(this);if(!i)return!1;t!==nr&&await (0,i$._)(this,im,oD).call(this,t,e)}catch(t){throw await (0,i$._)(this,iF,oK).call(this,t)}finally{(0,i$._)(this,iV,oz).call(this,0,-1)}return!0},"Pull")}function oW(){var t;return(0,iJ._)(this,eU)||""===this.pullURL&&(t=this.puller,aE.has(t))}async function oH(t,e){var i,a,n,s,r,l,o;let h=!0;try{return await t()}catch(t){return t instanceof ll||t instanceof r9?(h=!1,null===(i=(a=(0,iJ._)(this,e9)).debug)||void 0===i||i.call(a,"".concat(e," threw:\n"),t,"\nwith cause:\n",t.causedBy)):t instanceof lX?null===(n=(s=(0,iJ._)(this,e9)).error)||void 0===n||n.call(s,t):null===(r=(l=(0,iJ._)(this,e9)).info)||void 0===r||r.call(l,"".concat(e," threw:\n"),t),!1}finally{(0,iJ._)(this,ez)!==h&&((0,iK._)(this,ez,h),null===(o=this.onOnlineChange)||void 0===o||o.call(this,h),h&&(0,i$._)(this,iT,oY).call(this))}}async function ox(t,e,i){var a,n;let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:lJ,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:lJ,{clientID:l}=this,o=0,h;i=i.withContext(e);do{let a;let u=lG(l),c=i.withContext("requestID",u),{httpRequestInfo:d,result:w}=await t(u,c);if(h=w,!d)return{result:w,authFailure:!1};let{errorMessage:f,httpStatusCode:p}=d;if((f||p>=400)&&(null===(n=c.error)||void 0===n||n.call(c,"Got error response doing ".concat(e,": ").concat(p)+(f?": ".concat(f):""))),401!==p)return{result:w,authFailure:!1};if(!this.getAuth)return{result:w,authFailure:!0};try{await s(),a=await this.getAuth()}finally{await r()}if(null==a)return{result:w,authFailure:!0};this.auth=a,o++}while(o<8);return null===(a=i.info)||void 0===a||a.call(i,"Tried to reauthenticate too many times"),{result:h,authFailure:!0}}function oC(){var t;return(0,iJ._)(this,eU)||""===this.pushURL&&(t=this.pusher,r7.has(t))}async function oE(){if((0,i$._)(this,iM,oC).call(this))return!0;await (0,iJ._)(this,eB);let t=await (0,iJ._)(this,eK),{clientID:e}=this,i=await (0,iJ._)(this,eY);return(0,i$._)(this,ib,oH).call(this,async()=>{let{result:a}=await (0,i$._)(this,ik,ox).call(this,async(a,n)=>{try{(0,i$._)(this,iV,oz).call(this,1,0);let s=await lu(a,(0,iJ._)(this,e7),n,t,i,e,this.pusher,this.schemaVersion,1);return{result:s,httpRequestInfo:null==s?void 0:s.httpRequestInfo}}finally{(0,i$._)(this,iV,oz).call(this,-1,0)}},"push",(0,iJ._)(this,e9));if(void 0===a)return!0;let{response:n,httpRequestInfo:s}=a;return aH(n)?(0,i$._)(this,iD,oN).call(this,n):aW(n)&&await (0,i$._)(this,iE,oj).call(this),200===s.httpStatusCode},"Push")}function oN(t){let e={type:t.error};t.versionType&&(e.versionType=t.versionType),(0,i$._)(this,iN,oU).call(this,e)}async function oP(){await (0,iJ._)(this,eB);let t=await this.profileID,{clientID:e}=this,i=await (0,iJ._)(this,eY),{result:{beginPullResponse:a,requestID:n}}=await (0,i$._)(this,ik,ox).call(this,async(a,n)=>{let s=await li(t,e,i,this.schemaVersion,this.puller,a,(0,iJ._)(this,e7),7,n);return{result:{beginPullResponse:s,requestID:a},httpRequestInfo:s.httpRequestInfo}},"pull",(0,iJ._)(this,e9),()=>(0,i$._)(this,iV,oz).call(this,0,-1),()=>(0,i$._)(this,iV,oz).call(this,0,1)),{pullResponse:s}=a;aH(s)?(0,i$._)(this,iD,oN).call(this,s):aW(a.pullResponse)&&await (0,i$._)(this,iE,oj).call(this);let{syncHead:r,httpRequestInfo:l}=a;return{requestID:n,syncHead:r,ok:200===l.httpStatusCode}}async function oR(){ah(!(0,iJ._)(this,ie)),(0,iK._)(this,ie,!0);try{let{clientID:i}=this;if(await (0,iJ._)(this,eB),(0,iJ._)(this,eT))return;try{await lD((0,iJ._)(this,e9),i,(0,iJ._)(this,e7),(0,iJ._)(this,e6),(0,iJ._)(this,eZ),()=>this.closed,7)}catch(a){var t,e;if(a instanceof ro)(0,i$._)(this,iC,oV).call(this,i);else if((0,iJ._)(this,eT))null===(t=(e=(0,iJ._)(this,e9)).debug)||void 0===t||t.call(e,"Exception persisting during close",a);else throw a}}finally{(0,iK._)(this,ie,!1)}let{clientID:i}=this,a=await (0,iJ._)(this,eY);ah(a),(0,iJ._)(this,il).call(this,{clientID:i,clientGroupID:a})}async function oO(){let t;await (0,iJ._)(this,eB);let{clientID:e}=this;if(!(0,iJ._)(this,eT)){try{t=await lx((0,iJ._)(this,e9),(0,iJ._)(this,e7),(0,iJ._)(this,e6),e,(0,iJ._)(this,eZ),(0,iJ._)(this,eV),()=>this.closed,7)}catch(t){var i,a;if(t instanceof ro)(0,i$._)(this,iC,oV).call(this,e);else if((0,iJ._)(this,eT))null===(i=(a=(0,iJ._)(this,e9)).debug)||void 0===i||i.call(a,"Exception refreshing during close",t);else throw t}void 0!==t&&await (0,i$._)(this,iv,oI).call(this,t[0],t[1])}}function oA(){var t;null===(t=this.onClientStateNotFound)||void 0===t||t.call(this)}function oV(t){var e,i;null===(e=(i=(0,iJ._)(this,e9)).error)||void 0===e||e.call(i,"Client state not found on client, clientID: ".concat(t)),(0,i$._)(this,ix,oA).call(this)}async function oj(){var t,e;let i=await (0,iJ._)(this,eY);ah(i),(0,iK._)(this,eU,!0),await nC((0,iJ._)(this,e6),t=>nG(i,t)),null===(t=(e=(0,iJ._)(this,e9)).error)||void 0===t||t.call(e,"Client state not found on server, clientGroupID: ".concat(i)),(0,i$._)(this,ix,oA).call(this)}function oU(t){var e,i,a;null===(e=(i=(0,iJ._)(this,e9)).debug)||void 0===e||e.call(i,"Update needed, reason: ".concat(t)),null===(a=this.onUpdateNeeded)||void 0===a||a.call(this,t)}async function oL(){(0,iJ._)(this,ii)&&await (0,i$._)(this,iA,oT).call(this,"persist",(0,iJ._)(this,ir))}async function oq(t){var e,i;null===(e=(i=(0,iJ._)(this,e9)).debug)||void 0===e||e.call(i,"Handling persist",t);let a=await (0,iJ._)(this,eY);t.clientGroupID===a&&(0,i$._)(this,iO,oF).call(this)}async function oF(){(0,iJ._)(this,ia)&&await (0,i$._)(this,iA,oT).call(this,"refresh from storage",(0,iJ._)(this,io))}async function oT(t,e){try{await e.schedule()}catch(e){var i,a,n,s;e instanceof aX?null===(i=(a=(0,iJ._)(this,e9)).debug)||void 0===i||i.call(a,"Scheduled ".concat(t," did not complete before close.")):null===(n=(s=(0,iJ._)(this,e9)).error)||void 0===n||n.call(s,"Error during ".concat(t),e)}}function oz(t,e){(0,iK._)(this,e0,(0,iJ._)(this,e0)+t),(0,iK._)(this,e1,(0,iJ._)(this,e1)+e);let i=(0,iJ._)(this,e0)+(0,iJ._)(this,e1);if(1===t+e&&1===i||0===i){let t=i>0;Promise.resolve().then(()=>{var e;return null===(e=this.onSync)||void 0===e?void 0:e.call(this,t)})}}function oG(t,e){return(0,iJ._)(this,eZ)[t]=e,async i=>(await (0,i$._)(this,iq,oB).call(this,t,e,i,performance.now())).result}function oJ(t){let e=Object.create(null);for(let i in t)e[i]=(0,i$._)(this,iU,oG).call(this,i,t[i]);return e}async function oB(t,e,i,a){let n=null!=i?i:null;(0,iJ._)(this,eV).hasPendingSubscriptionRuns&&await Promise.resolve(),await (0,iJ._)(this,eB);let{clientID:s}=this;return nx((0,iJ._)(this,e7),async r=>{try{let l=await nb(sc,r),o=await sZ(l,t,n,null,r,a,s,7),h=new r1(s,await o.getMutationID(),"initial",o,(0,iJ._)(this,e9)),u=await e(h,i);rG(o);let c=await o.getMutationID(),[d,w]=await o.commitWithDiffs(sc,(0,iJ._)(this,eV));return(0,iK._)(this,eq,c),(0,iJ._)(this,e4).send(!1),await (0,i$._)(this,iv,oI).call(this,d,w),(0,i$._)(this,iP,oL).call(this),{result:u,ref:d}}catch(t){throw await (0,i$._)(this,iF,oK).call(this,t)}})}async function oK(t){return t instanceof ny&&await (0,i$._)(this,id,og).call(this)?new ro(this.clientID):t}function oY(t){return(0,iJ._)(this,ej).recoverMutations(t,(0,iJ._)(this,eB),(0,iJ._)(this,e6),(0,iJ._)(this,eF),(0,iJ._)(this,e8),(0,iJ._)(this,eL))}}}]);